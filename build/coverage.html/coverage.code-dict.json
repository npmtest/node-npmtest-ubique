{"/home/travis/build/npmtest/node-npmtest-ubique/test.js":"/* istanbul instrument in package npmtest_ubique */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ubique/lib.npmtest_ubique.js":"/* istanbul instrument in package npmtest_ubique */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ubique = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ubique = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ubique/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ubique && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ubique */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ubique\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ubique.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ubique.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ubique.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ubique.__dirname + '/lib.npmtest_ubique.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/index.js":"module.exports = require('./lib/ubique.js');","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/ubique.js":"/**\r\n * name: ubique\r\n * version: 0.5.1\r\n * update date: 2015-09-23\r\n * \r\n * author: Max Todaro <m.todaro.ge@gmail.com>\r\n * homepage: http://maxto.github.io/index.html\r\n * \r\n * description: A mathematical and quantitative library for Javascript and Node.js\r\n * \r\n *\r\n * The MIT License (MIT)\r\n * \r\n * Copyright© 2014-2015 Max Todaro\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\nvar ubique = {};\nrequire('./constants.js')(ubique);\nrequire('./extlib.js')(ubique);\nrequire('./datatype/arrayfun.js')(ubique);\nrequire('./datatype/clock.js')(ubique);\nrequire('./datatype/datavec.js')(ubique);\nrequire('./datatype/datenum.js')(ubique);\nrequire('./datatype/datestr.js')(ubique);\nrequire('./datatype/isarray.js')(ubique);\nrequire('./datatype/isempty.js')(ubique);\nrequire('./datatype/isfunction.js')(ubique);\nrequire('./datatype/isinteger.js')(ubique);\nrequire('./datatype/islogical.js')(ubique);\nrequire('./datatype/ismatrix.js')(ubique);\nrequire('./datatype/isnan.js')(ubique);\nrequire('./datatype/isnull.js')(ubique);\nrequire('./datatype/isnumber.js')(ubique);\nrequire('./datatype/isscalar.js')(ubique);\nrequire('./datatype/issingular.js')(ubique);\nrequire('./datatype/isstring.js')(ubique);\nrequire('./datatype/isundefined.js')(ubique);\nrequire('./datatype/isvector.js')(ubique);\nrequire('./datatype/month.js')(ubique);\nrequire('./datatype/now.js')(ubique);\nrequire('./datatype/randchar.js')(ubique);\nrequire('./datatype/strfind.js')(ubique);\nrequire('./datatype/today.js')(ubique);\nrequire('./datatype/vectorfun.js')(ubique);\nrequire('./datatype/weekday.js')(ubique);\nrequire('./elemop/ceil.js')(ubique);\nrequire('./elemop/cumdev.js')(ubique);\nrequire('./elemop/cummax.js')(ubique);\nrequire('./elemop/cummin.js')(ubique);\nrequire('./elemop/cumprod.js')(ubique);\nrequire('./elemop/cumsum.js')(ubique);\nrequire('./elemop/diff.js')(ubique);\nrequire('./elemop/dot.js')(ubique);\nrequire('./elemop/eq.js')(ubique);\nrequire('./elemop/floor.js')(ubique);\nrequire('./elemop/ge.js')(ubique);\nrequire('./elemop/gt.js')(ubique);\nrequire('./elemop/ldivide.js')(ubique);\nrequire('./elemop/le.js')(ubique);\nrequire('./elemop/lt.js')(ubique);\nrequire('./elemop/minus.js')(ubique);\nrequire('./elemop/mldivide.js')(ubique);\nrequire('./elemop/mod.js')(ubique);\nrequire('./elemop/mpower.js')(ubique);\nrequire('./elemop/mrdivide.js')(ubique);\nrequire('./elemop/mtimes.js')(ubique);\nrequire('./elemop/ne.js')(ubique);\nrequire('./elemop/plus.js')(ubique);\nrequire('./elemop/power.js')(ubique);\nrequire('./elemop/prod.js')(ubique);\nrequire('./elemop/rdivide.js')(ubique);\nrequire('./elemop/rem.js')(ubique);\nrequire('./elemop/round.js')(ubique);\nrequire('./elemop/sum.js')(ubique);\nrequire('./elemop/times.js')(ubique);\nrequire('./elemop/uminus.js')(ubique);\nrequire('./elemop/unique.js')(ubique);\nrequire('./elmath/abs.js')(ubique);\nrequire('./elmath/erf.js')(ubique);\nrequire('./elmath/erfc.js')(ubique);\nrequire('./elmath/erfcinv.js')(ubique);\nrequire('./elmath/erfinv.js')(ubique);\nrequire('./elmath/exp.js')(ubique);\nrequire('./elmath/log.js')(ubique);\nrequire('./elmath/sign.js')(ubique);\nrequire('./elmath/sqrt.js')(ubique);\nrequire('./linalgebra/det.js')(ubique);\nrequire('./linalgebra/inv.js')(ubique);\nrequire('./linalgebra/linsolve.js')(ubique);\nrequire('./linalgebra/lu.js')(ubique);\nrequire('./matarrs/array.js')(ubique);\nrequire('./matarrs/cat.js')(ubique);\nrequire('./matarrs/clone.js')(ubique);\nrequire('./matarrs/colon.js')(ubique);\nrequire('./matarrs/diag.js')(ubique);\nrequire('./matarrs/end.js')(ubique);\nrequire('./matarrs/eye.js')(ubique);\nrequire('./matarrs/falses.js')(ubique);\nrequire('./matarrs/find.js')(ubique);\nrequire('./matarrs/fix.js')(ubique);\nrequire('./matarrs/flatten.js')(ubique);\nrequire('./matarrs/flipdim.js')(ubique);\nrequire('./matarrs/fliplr.js')(ubique);\nrequire('./matarrs/flipud.js')(ubique);\nrequire('./matarrs/getcol.js')(ubique);\nrequire('./matarrs/getrow.js')(ubique);\nrequire('./matarrs/horzcat.js')(ubique);\nrequire('./matarrs/ind2sub.js')(ubique);\nrequire('./matarrs/iscolumn.js')(ubique);\nrequire('./matarrs/isrow.js')(ubique);\nrequire('./matarrs/issquare.js')(ubique);\nrequire('./matarrs/length.js')(ubique);\nrequire('./matarrs/linspace.js')(ubique);\nrequire('./matarrs/logspace.js')(ubique);\nrequire('./matarrs/matrix.js')(ubique);\nrequire('./matarrs/mergesort.js')(ubique);\nrequire('./matarrs/ncols.js')(ubique);\nrequire('./matarrs/ndims.js')(ubique);\nrequire('./matarrs/nrows.js')(ubique);\nrequire('./matarrs/numel.js')(ubique);\nrequire('./matarrs/ones.js')(ubique);\nrequire('./matarrs/rand.js')(ubique);\nrequire('./matarrs/repmat.js')(ubique);\nrequire('./matarrs/reshape.js')(ubique);\nrequire('./matarrs/setcol.js')(ubique);\nrequire('./matarrs/setrow.js')(ubique);\nrequire('./matarrs/size.js')(ubique);\nrequire('./matarrs/sort.js')(ubique);\nrequire('./matarrs/squeeze.js')(ubique);\nrequire('./matarrs/sub2ind.js')(ubique);\nrequire('./matarrs/subset.js')(ubique);\nrequire('./matarrs/subsetlin.js')(ubique);\nrequire('./matarrs/tomat.js')(ubique);\nrequire('./matarrs/transpose.js')(ubique);\nrequire('./matarrs/trues.js')(ubique);\nrequire('./matarrs/vertcat.js')(ubique);\nrequire('./matarrs/zeros.js')(ubique);\nrequire('./probdistr/jbtest.js')(ubique);\nrequire('./probdistr/normcdf.js')(ubique);\nrequire('./probdistr/norminv.js')(ubique);\nrequire('./probdistr/normpdf.js')(ubique);\nrequire('./quants/activereturn.js')(ubique);\nrequire('./quants/adjsharpe.js')(ubique);\nrequire('./quants/annadjsharpe.js')(ubique);\nrequire('./quants/annreturn.js')(ubique);\nrequire('./quants/annrisk.js')(ubique);\nrequire('./quants/avgdrawdown.js')(ubique);\nrequire('./quants/burkeratio.js')(ubique);\nrequire('./quants/cagr.js')(ubique);\nrequire('./quants/calmarratio.js')(ubique);\nrequire('./quants/cdrawdown.js')(ubique);\nrequire('./quants/downsidepot.js')(ubique);\nrequire('./quants/downsiderisk.js')(ubique);\nrequire('./quants/drawdown.js')(ubique);\nrequire('./quants/histcondvar.js')(ubique);\nrequire('./quants/histvar.js')(ubique);\nrequire('./quants/hurst.js')(ubique);\nrequire('./quants/inforatio.js')(ubique);\nrequire('./quants/irr.js')(ubique);\nrequire('./quants/jensenalpha.js')(ubique);\nrequire('./quants/m2sortino.js')(ubique);\nrequire('./quants/martinratio.js')(ubique);\nrequire('./quants/mdietz.js')(ubique);\nrequire('./quants/modigliani.js')(ubique);\nrequire('./quants/montecarlovar.js')(ubique);\nrequire('./quants/omegaratio.js')(ubique);\nrequire('./quants/painindex.js')(ubique);\nrequire('./quants/painratio.js')(ubique);\nrequire('./quants/paramcondvar.js')(ubique);\nrequire('./quants/paramvar.js')(ubique);\nrequire('./quants/percpos.js')(ubique);\nrequire('./quants/ret2tick.js')(ubique);\nrequire('./quants/ror.js')(ubique);\nrequire('./quants/sharpe.js')(ubique);\nrequire('./quants/sortino.js')(ubique);\nrequire('./quants/sterlingratio.js')(ubique);\nrequire('./quants/tick2ret.js')(ubique);\nrequire('./quants/tomonthly.js')(ubique);\nrequire('./quants/toweekly.js')(ubique);\nrequire('./quants/trackerr.js')(ubique);\nrequire('./quants/treynor.js')(ubique);\nrequire('./quants/twr.js')(ubique);\nrequire('./quants/ulcerindex.js')(ubique);\nrequire('./quants/upsidepot.js')(ubique);\nrequire('./reglin/interp1.js')(ubique);\nrequire('./reglin/linearreg.js')(ubique);\nrequire('./stats/corrcoef.js')(ubique);\nrequire('./stats/cov.js')(ubique);\nrequire('./stats/histc.js')(ubique);\nrequire('./stats/iqr.js')(ubique);\nrequire('./stats/kurtosis.js')(ubique);\nrequire('./stats/mad.js')(ubique);\nrequire('./stats/max.js')(ubique);\nrequire('./stats/mean.js')(ubique);\nrequire('./stats/median.js')(ubique);\nrequire('./stats/min.js')(ubique);\nrequire('./stats/mode.js')(ubique);\nrequire('./stats/moment.js')(ubique);\nrequire('./stats/pdist.js')(ubique);\nrequire('./stats/prctile.js')(ubique);\nrequire('./stats/quantile.js')(ubique);\nrequire('./stats/quartile.js')(ubique);\nrequire('./stats/range.js')(ubique);\nrequire('./stats/skewness.js')(ubique);\nrequire('./stats/std.js')(ubique);\nrequire('./stats/varc.js')(ubique);\nrequire('./stats/xkurtosis.js')(ubique);\nrequire('./stats/zscore.js')(ubique);\nrequire('./util/argsarray.js')(ubique);\nrequire('./util/format.js')(ubique);\nrequire('./datafeed/yahoo.js')(ubique);\nrequire('./datafeed/yahooSync.js')(ubique);\nmodule.exports = ubique;","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/constants.js":"/**\r\n * Constants properties\r\n */\r\nmodule.exports = function($u) {\r\n/**\r\n * Constants values\r\n * @type {number}\r\n */\r\n $u.Inf = Number.POSITIVE_INFINITY;\r\n $u.maxval = Number.MAX_VALUE;\r\n $u.minval = Number.MIN_VALUE;\r\n $u.PI = Math.PI;\r\n $u.E = Math.E;\r\n $u.LN2 = Math.LN2;\r\n $u.LN10 = Math.LN10;\r\n $u.LOG2E = Math.LOG2E;\r\n $u.LOG10E = Math.LOG10E;\r\n $u.SQRT1_2 = Math.SQRT1_2;\r\n $u.SQRT2 = Math.SQRT2;\r\n $u.eps = 2.2204460492503130808472633361816E-16;\r\n $u.phi = 1.618033988749894848204586834;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/extlib.js":"/**\r\n * External Library\r\n */\r\nmodule.exports = function($u) {\r\n // moment.js - Parse, validate, manipulate, and display dates in JavaScript (http://momentjs.com/)\r\n $u.__moment = require('moment');\r\n // request.js - Simplified HTTP request client (https://github.com/request/request)\r\n $u.__request = require('request');\r\n // sync-request.js  - Make synchronous web requests with cross platform support (https://github.com/ForbesLindesay/sync-request)\r\n $u.__syncrequest = require('sync-request');\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/arrayfun.js":"/**\r\n * Structures\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method arrayfun\r\n * @summary Apply function to each element of an array or matrix\r\n * @description Apply function to each element of an array or matrix. First arg is input element, the second one the function to apply, \r\n * then the parameters of the function.\r\n * \r\n * @param  {number|string|boolean|...} args variable input arguments\r\n * @return {number|string|boolean|...}     \r\n *\r\n * @example\r\n * ubique.arrayfun([1.4,2.3,3],Math.log);\r\n * // [ 0.336472, 0.832909, 1.098612 ]\r\n * \r\n * ubique.arrayfun([1.4,0,-10],ubique.sign);\r\n * // [ 1, 0, -1 ]\r\n * \r\n * ubique.arrayfun([[5,6],[1,3]],Math.pow,3);\r\n * // [ [ 125, 216 ], [ 1, 27 ] ]\r\n *\r\n * ubique.arrayfun([['cat','concat'],['cattle','catch the catfish']],ubique.strfind,'cat');\r\n * // [ [ [ 0 ], [ 3 ] ], [ [ 0 ], [ 0, 10 ] ] ]\r\n *\r\n * ubique.arrayfun([null,true,'hello',5,NaN],ubique.isnull);\r\n * // [ true, false, false, false, false ]\r\n *\r\n * ubique.arrayfun([null,true,'hello',5,NaN],ubique.islogical);\r\n * // [ false, true, false, false, false ]\r\n *\r\n * ubique.arrayfun([null,true,'hello',5,NaN],ubique.isstring);\r\n * // [ false, false, true, false, false ]\r\n *\r\n * ubique.arrayfun([null,true,'hello',5,NaN],ubique.isnumber);\r\n * // [ false, false, false, true, true ]\r\n *\r\n * ubique.arrayfun([null,true,'hello',5,{},undefined,'NaN',NaN],ubique.isnan);\r\n * // [ false, false, false, false, false, false, false, true ]\r\n */\r\n $u.arrayfun = function() {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var args = $u.argsarray.apply(null,arguments);\r\n  var x = args[0];\r\n  var fun = args[1];\r\n  if (!$u.isfunction(fun)) {\r\n    throw new Error('second input argument must be a function');\r\n  }\r\n  if ($u.isarray(x)) {\r\n    return x.map(function(a) {\r\n      return fun.apply(null,[].concat(a,args.slice(2,args.length)));\r\n    });\r\n  }\r\n  if ($u.ismatrix(x)) {\r\n    return x.map(function(a) {\r\n      return a.map(function(b) {\r\n        return fun.apply(null,[].concat(b,args.slice(2,args.length)));\r\n      });\r\n    });\r\n  }\r\n  return fun.apply(null,[].concat(x,args.slice(2,args.length)));\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/clock.js":"/**\r\n * Dates and Time\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method clock\r\n * @summary Current date and time as date vector\r\n * @description Current date and time as date vector. Returns an array:\r\n * [year month day hour minute seconds]\r\n * \r\n * @param {empty} empty no arguments\r\n * @return {array}\r\n * \r\n * @example\r\n * ubique.clock();\r\n * // [ 2015, 5, 28, 11, 51, 0, 801 ]\r\n */\r\n $u.clock = function() {\r\n  var now = $u.__moment().toArray();\r\n  now[1] = now[1] + 1;\r\n  return now;\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/datavec.js":"/**\r\n * Dates and Time\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method datevec\r\n * @summary Convert date and time to vector of components\r\n * @description Convert date and time to vector of components. Based on [moment.js](http://momentjs.com)\r\n * \r\n * |Identifier| Example          | Description |\r\n * | ----------- | ---------------- | ----------- |\r\n * | `YYYY`      | `2014`           | 4 digit year |\r\n * | `YY`        | `14`             | 2 digit year |\r\n * | `Q`         | `1..4`           | Quarter of year. Sets month to first month in quarter. |\r\n * | `M MM`      | `1..12`          | Month number |\r\n * | `MMM MMMM`  | `January..Dec`   | Month name in locale set by `moment.locale()` |\r\n * | `D DD`      | `1..31`          | Day of month |\r\n * | `Do`        | `1st..31st`      | Day of month with ordinal |\r\n * | `DDD DDDD`  | `1..365`         | Day of year |\r\n * | `X`         | `1410715640.579` | Unix timestamp |\r\n * | `x`         | `1410715640579`  | Unix ms timestamp |\r\n * |\r\n * | `gggg`   | `2014`  | Locale 4 digit week year |\r\n * | `gg`     | `14`    | Locale 2 digit week year |\r\n * | `w ww`   | `1..53` | Locale week of year |\r\n * | `e`      | `1..7`  | Locale day of week |\r\n * | `GGGG`   | `2014`  | ISO 4 digit week year |\r\n * | `GG`     | `14`    | ISO 2 digit week year |\r\n * | `W WW`   | `1..53` | ISO week of year |\r\n * | `E`      | `1..7`  | ISO day of week |\r\n * |\r\n * | `H HH`         | `0..23`  | 24 hour time |\r\n * | `h hh`         | `1..12`  | 12 hour time used with `a A`. |\r\n * | `a A`          | `am pm`  | Post or ante meridiem |\r\n * | `m mm`         | `0..59`  | Minutes |\r\n * | `s ss`         | `0..59`  | Seconds |\r\n * | `S`            | `0..9`   | Tenths of a second |\r\n * | `SS`           | `0..99`  | Hundreds of a second |\r\n * | `SSS`          | `0..999` | Thousandths of a second |\r\n * | `Z ZZ`         | `+12:00` | Offset from UTC as `+-HH:mm`, `+-HHmm`, or `Z` |\r\n *\r\n * @param  {string|number|array|matrix} d string or number (unix) \r\n * @param  {string} fmt format string\r\n * @return {array|matrix}\r\n *\r\n * @example\r\n * ubique.datevec('2015-01-01 03:34:05','YYYY-MM-DD HH:mm:ss');\r\n * // [ 2015, 1, 1, 3, 34, 5, 0 ]\r\n * \r\n * ubique.datevec(['31-12-2014','31-01-2015'],'DD-MM-YYYY');\r\n * // [ [ 2014, 12, 31, 0, 0, 0, 0 ], [ 2015, 1, 31, 0, 0, 0, 0 ] ]\r\n * \r\n * ubique.datevec([['31-12-2014','31-01-2015'],['15-02-2015','01-03-2015']],'DD-MM-YYYY');\r\n * // [ [ [ 2014, 12, 31, 0, 0, 0, 0 ], [ 2015, 1, 31, 0, 0, 0, 0 ] ],\r\n * //   [ [ 2015, 2, 15, 0, 0, 0, 0 ], [ 2015, 3, 1, 0, 0, 0, 0 ] ] ]\r\n *\r\n * // from '2015-04-05 12:20:30' to Unix 1428236430\r\n * ubique.datevec(1428236430);\r\n * // [ 2015, 4, 5, 12, 20, 30, 0 ]\r\n */\r\n $u.datevec= function(d,fmt) {\r\n  if (arguments.length < 1) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if ($u.isstring(d)) {\r\n    if (!fmt) {\r\n      throw new Error('insert format for date string');\r\n    }\r\n  }\r\n  // Note: because this mirrors the native Date parameters,\r\n  // months, hours, minutes, seconds, and milliseconds are all zero indexed.\r\n  // Years and days of the month are 1 indexed.\r\n  var _datevec = function(a,fmt) {\r\n    if ($u.isstring(a)) {\r\n      var dv = $u.__moment(a,fmt).toArray();\r\n    } else \r\n    if ($u.isnumber(a)) {\r\n      var dv = $u.__moment.utc(a,'X').toArray();\r\n    } else {\r\n      throw new Error('input must be a string or unix timestamp');\r\n    }\r\n    dv[1] = dv[1] + 1;\r\n    return dv;\r\n  }\r\n  return $u.arrayfun(d,_datevec,fmt);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/datenum.js":"/**\r\n * Dates and Time\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method datenum\r\n * @summary Convert date and time to serial date number (Unix)\r\n * @description Convert date and time to serial date number (Unix). Based on [moment.js](http://momentjs.com)\r\n * \r\n * |Identifier| Example          | Description |\r\n * | ----------- | ---------------- | ----------- |\r\n * | `YYYY`      | `2014`           | 4 digit year |\r\n * | `YY`        | `14`             | 2 digit year |\r\n * | `Q`         | `1..4`           | Quarter of year. Sets month to first month in quarter. |\r\n * | `M MM`      | `1..12`          | Month number |\r\n * | `MMM MMMM`  | `January..Dec`   | Month name in locale set by `moment.locale()` |\r\n * | `D DD`      | `1..31`          | Day of month |\r\n * | `Do`        | `1st..31st`      | Day of month with ordinal |\r\n * | `DDD DDDD`  | `1..365`         | Day of year |\r\n * | `X`         | `1410715640.579` | Unix timestamp |\r\n * | `x`         | `1410715640579`  | Unix ms timestamp |\r\n * |\r\n * | `gggg`   | `2014`  | Locale 4 digit week year |\r\n * | `gg`     | `14`    | Locale 2 digit week year |\r\n * | `w ww`   | `1..53` | Locale week of year |\r\n * | `e`      | `1..7`  | Locale day of week |\r\n * | `GGGG`   | `2014`  | ISO 4 digit week year |\r\n * | `GG`     | `14`    | ISO 2 digit week year |\r\n * | `W WW`   | `1..53` | ISO week of year |\r\n * | `E`      | `1..7`  | ISO day of week |\r\n * |\r\n * | `H HH`         | `0..23`  | 24 hour time |\r\n * | `h hh`         | `1..12`  | 12 hour time used with `a A`. |\r\n * | `a A`          | `am pm`  | Post or ante meridiem |\r\n * | `m mm`         | `0..59`  | Minutes |\r\n * | `s ss`         | `0..59`  | Seconds |\r\n * | `S`            | `0..9`   | Tenths of a second |\r\n * | `SS`           | `0..99`  | Hundreds of a second |\r\n * | `SSS`          | `0..999` | Thousandths of a second |\r\n * | `Z ZZ`         | `+12:00` | Offset from UTC as `+-HH:mm`, `+-HHmm`, or `Z` |\r\n *\r\n * @param  {string|array|matrix} d string vector of components\r\n * @param  {string} fmt format string\r\n * @return {string|array|matrix}\r\n *\r\n * @example\r\n * ubique.datenum('31-12-2014','DD-MM-YYYY');\r\n * // 1419984000\r\n * \r\n * ubique.datenum(['31-12-2014','31-01-2015'],'DD-MM-YYYY');\r\n * // [ 1419984000, 1422662400 ]\r\n * \r\n * ubique.datenum([['31-12-2014','31-01-2015'],['15-02-2015','01-03-2015']],'DD-MM-YYYY');\r\n * // [ [ 1419984000, 1422662400 ], [ 1423958400, 1425168000 ] ]\r\n *\r\n * ubique.datenum([ 2015, 4, 5, 12, 20, 30, 0 ]);\r\n * // 1428236430\r\n *\r\n * ubique.datenum([ [ 2013, 1, 31, 0, 0, 0, 0 ],[ 2014, 2, 28, 0, 0, 0, 0 ],[ 2015, 4, 30, 0, 0, 0, 0 ] ]);\r\n * // [ 1359590400, 1393545600, 1430352000 ]\r\n */\r\n $u.datenum = function(d,fmt) {\r\n  if (arguments.length < 1) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if ($u.isstring(d)) {\r\n    if (!fmt) {\r\n      throw new Error('insert format for date string');\r\n    }\r\n  }\r\n  var _datenum = function(a,fmt) {\r\n    return $u.__moment.utc(a,fmt).unix();\r\n  }\r\n  if ($u.isstring(d)) {\r\n    return _datenum(d,fmt);\r\n  }\r\n  if ($u.isarray(d)) {\r\n    var checknum = d.filter(function(el) {\r\n      return $u.isnumber(el);\r\n    });\r\n    if (checknum.length === d.length) {\r\n      return $u.__moment.utc(d,'YYYYMMDDhhmmss').unix();\r\n    } else {\r\n      return $u.arrayfun(d,_datenum,fmt);\r\n    }\r\n  }\r\n\r\n  if ($u.ismatrix(d)) {\r\n    if ($u.isarray(d[0])) {\r\n     return d.map(function(a) {\r\n      return $u.datenum(a,fmt);\r\n    });\r\n   }\r\n   return $u.arrayfun(d,_datenum,fmt);\r\n }\r\n \r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/datestr.js":"/**\r\n * Dates and Time\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method datestr\r\n * @summary Convert serial date number (Unix) to string format\r\n * @description Convert serial date number (Unix) to string format. Based on [moment.js](http://momentjs.com)\r\n *\r\n * |Identifier| Example          | Description |\r\n * | ----------- | ---------------- | ----------- |\r\n * | `YYYY`      | `2014`           | 4 digit year |\r\n * | `YY`        | `14`             | 2 digit year |\r\n * | `Q`         | `1..4`           | Quarter of year. Sets month to first month in quarter. |\r\n * | `M MM`      | `1..12`          | Month number |\r\n * | `MMM MMMM`  | `January..Dec`   | Month name in locale set by `moment.locale()` |\r\n * | `D DD`      | `1..31`          | Day of month |\r\n * | `Do`        | `1st..31st`      | Day of month with ordinal |\r\n * | `DDD DDDD`  | `1..365`         | Day of year |\r\n * | `X`         | `1410715640.579` | Unix timestamp |\r\n * | `x`         | `1410715640579`  | Unix ms timestamp |\r\n * |\r\n * | `gggg`   | `2014`  | Locale 4 digit week year |\r\n * | `gg`     | `14`    | Locale 2 digit week year |\r\n * | `w ww`   | `1..53` | Locale week of year |\r\n * | `e`      | `1..7`  | Locale day of week |\r\n * | `GGGG`   | `2014`  | ISO 4 digit week year |\r\n * | `GG`     | `14`    | ISO 2 digit week year |\r\n * | `W WW`   | `1..53` | ISO week of year |\r\n * | `E`      | `1..7`  | ISO day of week |\r\n * |\r\n * | `H HH`         | `0..23`  | 24 hour time |\r\n * | `h hh`         | `1..12`  | 12 hour time used with `a A`. |\r\n * | `a A`          | `am pm`  | Post or ante meridiem |\r\n * | `m mm`         | `0..59`  | Minutes |\r\n * | `s ss`         | `0..59`  | Seconds |\r\n * | `S`            | `0..9`   | Tenths of a second |\r\n * | `SS`           | `0..99`  | Hundreds of a second |\r\n * | `SSS`          | `0..999` | Thousandths of a second |\r\n * | `Z ZZ`         | `+12:00` | Offset from UTC as `+-HH:mm`, `+-HHmm`, or `Z` |\r\n * \r\n * @param  {number|array|matrix} d ISO Unix datetime\r\n * @param  {string} fmt format string (def: 'YYYY-MM-DD')\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.datestr(1419984000);\r\n * // 2014-12-31\r\n * \r\n * ubique.datestr([ 1419984000, 1422662400 ],'DD-MMM-YY');\r\n * // [ '31-Dec-14', '31-Jan-15' ]\r\n * \r\n * ubique.datestr([ [ 1419984000, 1422662400 ], [ 1423958400, 1425168000 ] ],'YY-MM-DD hh:mm:ss');\r\n * // [ [ '14-12-31 12:00:00', '15-01-31 12:00:00' ],\r\n * // [ '15-02-15 12:00:00', '15-03-01 12:00:00' ] ]\r\n */\r\n $u.datestr = function(d,fmt) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  fmt = fmt == null ? 'YYYY-MM-DD' : fmt;\r\n  var _datestr = function(a,fmt) {\r\n    return $u.__moment.utc(a,'X').format(fmt);\r\n  }\r\n  return $u.arrayfun(d,_datestr,fmt);\r\n\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isarray.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method isarray\r\n * @summary True for array\r\n * @description  True for array\r\n * \r\n * @param  {array} x input element\r\n * @return {boolean}   \r\n *\r\n * @example\r\n * ubique.isarray([1.4,2.3,3]);\r\n * // true\r\n */\r\n $u.isarray = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return Array.isArray(x) && !Array.isArray(x[0]);\r\n}\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isempty.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method isempty\r\n * @summary True for empty array or matrix\r\n * @description  True for empty array or matrix\r\n *              \r\n * @param  {array|matrix} x input matrix\r\n * @return {Boolean}   \r\n *\r\n * @example\r\n * ubique.isempty([]);\r\n * // true\r\n * \r\n * ubique.isempty([[]]);\r\n * // true\r\n */\r\n $u.isempty = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if ($u.isarray(x) && x.length === 0) {\r\n   return true;\r\n }\r\n if ($u.ismatrix(x) && x[0].length === 0) {\r\n   return true;\r\n }\r\n return false;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isfunction.js":"/**\r\n * Data Type Identification\r\n */\r\n module.exports = function($u) {\r\n/**\r\n* @method isfunction\r\n* @summary True for function\r\n* @description true for function\r\n* \r\n* @param  {function} x function\r\n* @return {Boolean}   \r\n*\r\n* @example\r\n* ubique.isfunction(function(a){return console.log(a);});\r\n* // true\r\n* \r\n* ubique.isfunction(Math.log);\r\n* // true\r\n*/\r\n$u.isfunction = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return typeof x === 'function';\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isinteger.js":"/**\r\n * Data Type Identification\r\n */\r\n module.exports = function($u) {\r\n/**\r\n* @method isinteger\r\n* @summary True for integer\r\n* @description  True for integer\r\n* \r\n* @param  {number} x element\r\n* @return {boolean}\r\n*\r\n* @example\r\n* ubique.isinteger(5);\r\n* // true\r\n*/\r\n$u.isinteger = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return $u.isnumber(x) && Math.round(x) === x;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/islogical.js":"/**\r\n * Logical Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method islogical\r\n * @summary True for logical input\r\n * @description True for logical input\r\n *              \r\n * @param  {boolean} x element\r\n * @return {boolean}   \r\n *\r\n * @example\r\n * ubique.islogical(true);\r\n * // true\r\n */\r\n $u.islogical = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return typeof x === 'boolean';\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/ismatrix.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method ismatrix\r\n * @summary True for matrix\r\n * @description True for array of array (matrix)\r\n * \r\n * @param  {matrix} x matrix\r\n * @return {Boolean}  \r\n *\r\n * @example\r\n * ubique.ismatrix([[1,3,4]]);\r\n * // true\r\n * \r\n * ubique.ismatrix([[1],[3],[4]]);\r\n * // true\r\n */\r\n $u.ismatrix = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t} \r\n \tif ($u.isundefined(x) || $u.isnull(x) || !$u.isarray(x[0])) {\r\n \t\treturn false;\r\n \t}\r\n \treturn $u.isarray(x[0]);\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isnan.js":"/**\r\n * Numeric Types\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method isnan\r\n * @summary True only for NaN input\r\n * @description True only for NaN input. For [null,true,'hello',5,{},undefined,'NaN'] returns False.\r\n *              \r\n * @param  {NaN} x element\r\n * @return {boolean}   \r\n *\r\n * @example\r\n * ubique.isnan(NaN);\r\n * // true\r\n */\r\n $u.isnan = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return x != x;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isnull.js":"/**\r\n * Data Type Identification\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method isnull\r\n * @summary True for null values\r\n * @description  True for null values\r\n * \r\n * @param  {null} x element\r\n * @return {boolean}   \r\n *\r\n * @example\r\n * ubique.isnull(null);\r\n * // true\r\n */\r\n $u.isnull = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return x === null;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isnumber.js":"/**\r\n * Data Type Identification\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method isnumber\r\n * @summary True for number\r\n * @description  True for number or NaN value\r\n * \r\n * @param  {number} x element\r\n * @return {boolean}   \r\n *\r\n * @example\r\n * ubique.isnumber(5);\r\n * // true\r\n * ubique.isnumber(NaN);\r\n * // true \r\n */\r\n $u.isnumber = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n \treturn typeof x === 'number';\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isscalar.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method isscalar\r\n * @summary True for scalar input\r\n * @description True for scalar input\r\n *              \r\n * @param  {number|array|matrix} x input \r\n * @return {Boolean}   \r\n *\r\n * @example\r\n * ubique.isscalar(2);\r\n * // true\r\n * \r\n * ubique.isscalar([2]);\r\n * // true\r\n * \r\n * ubique.isscalar([[2]]);\r\n * // true\r\n */\r\n $u.isscalar = function(x) {\r\n \tif ($u.nrows(x) === 1 && $u.ncols(x) === 1) {\r\n \t\treturn true;\r\n \t}\r\n \treturn false;\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/issingular.js":"/**\r\n * Matrix Types\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method issingular\r\n * @summary True for singular matrix\r\n * @description True for singular matrix. A square matrix which does not have an inverse. A matrix is singular if and only if its determinant is zero.\r\n * \r\n * @param  {matrix} x input matrix\r\n * @return {boolean}     \r\n *\r\n * @example\r\n * ubique.issingular([[2,6],[1,3]]);\r\n * // false\r\n */\r\n $u.issingular = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if ($u.isnumber(x) || $u.isarray(x)) {\r\n    throw new Error('input must be a matrix');\r\n  }\r\n  if (!$u.issquare(x)) {\r\n    throw new Error('input must be a square matrix');\r\n  }\r\n  var n = $u.ncols(x);\r\n  for (var i = 0;i < n;i++) {\r\n    if (x[i][i] === 0) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isstring.js":"/**\r\n * Data Type Identification\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method isstring\r\n * @summary True for string values\r\n * @description  True for string values\r\n * \r\n * @param  {string} x element\r\n * @return {boolean|array}   \r\n *\r\n * @example\r\n * ubique.isstring('test');\r\n * // true\r\n */\r\n $u.isstring = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return typeof x === 'string';\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isundefined.js":"/**\r\n * Data Type Identification\r\n */\r\n module.exports = function($u) {\r\n /**\r\n * @method isundefined\r\n * @summary True for undefined values\r\n * @description  True for undefined values\r\n * \r\n * @param  {undefined} x element\r\n * @return {boolean}   \r\n *\r\n * @example\r\n * ubique.isundefined(undefined);\r\n * // true\r\n */\r\n $u.isundefined = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return x === undefined;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/isvector.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method isvector\r\n * @summary True for vector input\r\n * @description True for vector input. Vector can have the same dimension of array but array is array and vector\r\n * is an array of array (= matrix with 1 column or row)\r\n *              \r\n * @param  {matrix} x matrix with dimension Mx1 or 1xN\r\n * @return {boolean}   \r\n *\r\n * @example\r\n * ubique.isvector([[5,6,7]]);\r\n * // true\r\n * \r\n * ubique.isvector([[5],[6],[7]]);\r\n * // true\r\n */\r\n $u.isvector = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.ismatrix(x)) {\r\n \t\tif (($u.iscolumn(x) === true) || ($u.isrow(x) === true)) {\r\n \t\t\treturn true;\r\n \t\t}\r\n \t\treturn false;\r\n \t}\r\n \treturn false;\r\n }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/month.js":"/**\r\n * Dates and Time\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method month\r\n * @summary Month of date\r\n * @description Returns a number representing the month for each element in X.\r\n * Months are 0 indexed, Jan is 0 and Dec is 11.\r\n * Based on [moment.js](http://momentjs.com)\r\n * \r\n * @param  {number|array|matrix} x serial date number (Unix)\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.month(1424708525);\r\n * // 1\r\n * \r\n * ubique.month([1414886399,1414972799]);\r\n * // [ 10, 10 ]\r\n * \r\n * ubique.month([[1414886399,1414972799],[1415059199,1415145599]]);\r\n * // [ [ 10, 10 ], [ 10, 10 ] ]\r\n */\r\n $u.month = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _month = function(a) {\r\n    return $u.__moment.unix(a).month();\r\n  }\r\n  return $u.arrayfun(x,_month);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/now.js":"/**\r\n * Dates and Time\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method now\r\n * @summary Current date and time as date number (unix)\r\n * @description Current date and time as date number (unix)\r\n * \r\n * @param {empty} empty no arguments\r\n *\r\n * @example\r\n * ubique.now();\r\n * // 1430759861\r\n */\r\n $u.now = function() {\r\n  return $u.datenum($u.clock());\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/randchar.js":"/**\r\n * Create and Concatenate Strings\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method randchar\r\n * @summary Generate a random alpha-numeric string\r\n * @description Generate a random alpha-numeric string\r\n * \r\n * @param  {number} n number of characters to generate (def: 6)\r\n * @param  {string} strset character set to get random sample\r\n * @return {string}        \r\n *\r\n * @example\r\n * ubique.randchar(12,'ABCD!-|/%&$\\1234567890');\r\n * // D&80%BB/C%B\r\n * \r\n * ubique.randchar(16,'ABCDEFGHILMNOPQRSTUVZ-1234567890');\r\n * // U68MP-U7ZI26T2HS\r\n */\r\n $u.randchar = function(n,strset) {\r\n  if (arguments.length === 0) {\r\n    return '';\r\n  }\r\n  strset = strset == null ? 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' : strset;\r\n  return Array.apply(0, Array(n)).map(function() {\r\n    return (function(charset) {\r\n      return charset.charAt(Math.floor(Math.random() * charset.length))\r\n    }(strset));\r\n  }).join('')\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/strfind.js":"/**\r\n * Parse Strings\r\n */\r\n module.exports = function ($u) {\r\n/**\r\n * @method strfind\r\n * @summary Find one string within another\r\n * @description Find one string within another. If pattern length > text length returns null.\r\n * \r\n * @param  {string} str data to be searched\r\n * @param  {string} pattern search pattern\r\n * @return {array} indices of occurrences of pattern\r\n *  \r\n * @example\r\n * var mystr = 'find indices in the string';\r\n *\r\n * ubique.strfind(mystr,'in');\r\n * // [ 1, 5, 13, 23 ]\r\n */\r\n $u.strfind = function (str,pattern) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if ($u.isstring(str) && $u.isstring(pattern) && (str.length >= pattern.length)) {\r\n    var i = str.indexOf(pattern);\r\n    var posidx = [];\r\n    while(i >= 0) {\r\n      posidx.push(i);\r\n      i = str.indexOf(pattern, i + 1);\r\n    }\r\n    return posidx;\r\n  } else {\r\n    throw new Error('unknown arguments');\r\n  }\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/today.js":"/**\r\n * Dates and Time\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method today\r\n * @summary Current date\r\n * @description Current date\r\n * \r\n * @param {empty} empty no arguments\r\n *\r\n * @example\r\n * ubique.today();\r\n * // 1430697600\r\n */\r\n $u.today = function() {\r\n  var t = $u.clock();\r\n  return $u.datenum([t[0],t[1],t[2]]);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/vectorfun.js":"/**\r\n * Structures\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method  vectorfun\r\n * @summary Apply a function to each vector column or row of a matrix \r\n * @description Apply a function to each vector column or row of a matrix. The syntax is:\r\n * \r\n * vectorfun(dim,x,func,arg1,arg2....)\r\n * \r\n * @param  {number|string|boolean|...} args variable input arguments\r\n * @return {number|string|boolean|...}  \r\n *\r\n * @example\r\n * var testfun = function(a,b,c){return ubique.mean(a)*b+c;};\r\n * \r\n * ubique.vectorfun(0,[[5,6,5],[7,8,-1]],testfun,5,10)\r\n * // [ [ 36.666667 ], [ 33.333333 ] ]\r\n * \r\n * ubique.vectorfun(1,[[5,6,5],[7,8,-1]],testfun,5,10)\r\n * // [ [ 40, 45, 20 ] ]\r\n */\r\n $u.vectorfun = function() {\r\n \tif (arguments.length < 3) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  var args = $u.argsarray.apply(null,arguments);\r\n  var argslen = args.length;\r\n  var dim = args[0];\r\n  var x = args[1];\r\n  var fun = args[2];\r\n  var varargin = args.slice(3,args.length);\r\n  if (dim !== 0 && dim !== 1) {\r\n    throw new Error('dimension must be 0 (rows) or 1 (columns)');\r\n  }\r\n  if (!$u.isfunction(fun)) {\r\n    throw new Error('third input argument must be a function');\r\n  }\r\n  if (dim === 1) {\r\n    var ndim = $u.ncols(x);\r\n    var narray = $u.getcol;\r\n  }\r\n  if (dim === 0) {\r\n    var ndim = $u.nrows(x);\r\n    var narray = $u.getrow;\r\n  }\r\n  if ($u.isarray(x)) {\r\n    if ($u.isempty(varargin)) {\r\n      return fun.apply(null,[x]);\r\n    } \r\n    return fun.apply(null,[].concat([x]).concat(varargin));\r\n  }\r\n  var v = [];\r\n  if ($u.ismatrix(x)) {\r\n    for (var i = 0; i < ndim; i++) {\r\n      var d = narray(x,i);\r\n      var temp = fun.apply(null,[].concat([d]).concat(varargin));\r\n      v.push(temp);\r\n    }\r\n  }\r\n  if (dim === 1) {\r\n    if ($u.isarray(v)) {\r\n      return [v];\r\n    }\r\n    return $u.squeeze($u.transpose(v));\r\n  }\r\n  if (dim === 0) {\r\n    if ($u.isarray(v)) {\r\n      return $u.transpose(v);\r\n    }\r\n  }\r\n  return $u.squeeze(v);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datatype/weekday.js":"/**\r\n * Dates and Time\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method weekday\r\n * @summary Day of week\r\n * @description Returns a number representing the day of the week for each element in X.\r\n * The ISO day of the week begins with 1 Monday, 2 Tuesday ... 7 Sunday.\r\n * Based on [moment.js](http://momentjs.com)\r\n * \r\n * @param  {number|array|matrix} x serial date number (Unix)\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.weekday(1426636800);\r\n * // 3\r\n * \r\n * ubique.weekday([ 1424908800, 1426636800 ]);\r\n * // [ 4, 3 ]\r\n * \r\n * ubique.weekday([ [ 1424908800, 1426636800 ], [ 1427328000, 1429315200 ] ]);\r\n * // [ [ 4, 3 ], [ 4, 6 ] ]\r\n */\r\n $u.weekday = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _weekday = function(a) {\r\n    return $u.__moment.utc(a,'X').isoWeekday();\r\n  }\r\n  return $u.arrayfun(x,_weekday);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/ceil.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n \t/**\r\n * @method ceil\r\n * @summary Round toward positive infinity\r\n * @description Round toward positive infinity\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @param  {number} x number of decimals\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.ceil(Math.PI,12);\r\n * // 3.141593\r\n * \r\n * ubique.ceil(3.78);\r\n * // 4\r\n * \r\n * ubique.ceil([4.51,-1.4]);\r\n * // [ 5, -1 ]\r\n * \r\n * ubique.ceil([[4.5134,-1.4345],[3.7809,0.0134]],2);\r\n * // [ [ 4.52, -1.43 ], [ 3.79, 0.02 ] ]\r\n */\r\n $u.ceil = function(x,n) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tn = n == null ? 0 : n;\r\n \tvar p = Math.pow(10,n);\r\n  var _ceil = function(a) {\r\n    return Math.ceil(a * p) / p;\r\n  }\r\n  return $u.arrayfun(x,_ceil);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/cumdev.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method cumdev\r\n * @summary Cumulative mean deviation\r\n * @description  Cumulative mean deviation of the values in array X\r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number} dim dimension selected, 1: column 0: row (def: 1)\r\n * @return {array|matrix}   \r\n *\r\n * @example\r\n * var b = [[-1,3,-1],[4,5,9]];\r\n * var c = [5,6,3];\r\n *\r\n * ubique.cumdev([5,6,3]);\r\n * // [ 0.333333, 1.666667, -0 ]\r\n * \r\n * ubique.cumdev([[-1,3,-1],[4,5,9]],0);\r\n * // [ [ -1.333333, 1.333333, 0 ], [ -2, -3, 0 ] ]\r\n * \r\n * ubique.cumdev([[-1,3,-1],[4,5,9]]);\r\n * // [ [ -2.5, -1, -5 ], [ 0, 0, 0 ] ]\r\n */\r\n $u.cumdev = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tdim = dim == null ? 1 : dim;\r\n \tvar _cumdev = function(a) {\r\n \t\treturn $u.cumsum($u.minus(a,$u.mean(a)));\r\n \t}\r\n   return $u.vectorfun(dim,x,_cumdev);\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/cummax.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method cummax\r\n * @summary Cumulative max of array elements\r\n * @description Cumulative max of array elements\r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number} dim dimension selected, 1: column 0: row (def: 1)\r\n * @return {array|matrix}   \r\n *\r\n * @example\r\n * ubique.cummax([5,6,3]);\r\n * // [ 5, 6, 6 ]\r\n * \r\n * ubique.cummax([[5,6,5],[7,8,-1]]);\r\n * // [ [ 5, 6, 5 ], [ 7, 8, 5 ] ]\r\n * \r\n * ubique.cummax([[5,6,5],[7,8,-1]],0);\r\n * // [ [ 5, 6, 6 ], [ 7, 8, 8 ] ]\r\n */\r\n $u.cummax = function(x,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim = dim == null ? 1 : dim;\r\n  var _cummax =  function(a) {\r\n    var v = [];\r\n    v[0] = a[0];\r\n    for (var i = 1;i < a.length;i++) {\r\n      if (a[i] >= v[i - 1]) {\r\n        v[i] = a[i];\r\n      } else { \r\n        v[i] = v[i - 1];\r\n      }\r\n    }\r\n    return v;\r\n  }\r\n  return $u.vectorfun(dim,x,_cummax);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/cummin.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n /**\r\n * @method cummin\r\n * @summary Cumulative min of array elements\r\n * @description Cumulative min of array elements\r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number} dim dimension selected, 1: column 0: row (def: 1)\r\n * @return {array|matrix}   \r\n *\r\n * @example\r\n * ubique.cummin([5,6,3]);\r\n * // [ 5, 5, 3 ]\r\n * \r\n * ubique.cummin([[5,6,5],[7,8,-1]]);\r\n * // [ [ 5, 6, 5 ], [ 5, 6, -1 ] ]\r\n * \r\n * ubique.cummin([[5,6,5],[7,8,-1]],0);\r\n * // [ [ 5, 5, 5 ], [ 7, 7, -1 ] ]\r\n */\r\n $u.cummin = function(x,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim = dim == null ? 1 : dim;\r\n  var _cummin =  function(a) {\r\n    var v = [];\r\n    v[0] = a[0];\r\n    for (var i = 1;i < a.length;i++) {\r\n      if (a[i] < v[i - 1]) {\r\n        v[i] = a[i];\r\n      } else { \r\n        v[i] = v[i - 1];\r\n      }\r\n    }\r\n    return v;\r\n  }\r\n  return $u.vectorfun(dim,x,_cummin);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/cumprod.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n /**\r\n * @method cumprod\r\n * @summary Cumulative product of array elements\r\n * @description Cumulative product of array elements\r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number} dim dimension selected, 1: column 0: row (def: 1)\r\n * @return {array|matrix}   \r\n *\r\n * @example\r\n * ubique.cumprod([5,6,3]);\r\n * // [ 5, 30, 90 ]\r\n * \r\n * ubique.cumprod([[5,6,5],[7,8,-1]]);\r\n * // [ [ 5, 6, 5 ], [ 35, 48, -5 ] ]\r\n * \r\n * ubique.cumprod([[5,6,5],[7,8,-1]],0);\r\n * // [ [ 5, 30, 150 ], [ 7, 56, -56 ] ]\r\n */\r\n $u.cumprod = function(x,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim = dim == null ? 1 : dim;\r\n  var _cumprod =  function(a) {\r\n    var v = [];\r\n    v[0] = a[0];\r\n    for (var i = 1;i < a.length;i++) {\r\n      v[i] = v[i - 1] * a[i];\r\n    }\r\n    return v;\r\n  }\r\n  return $u.vectorfun(dim,x,_cumprod);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/cumsum.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method cumsum\r\n * @summary Cumulative sum of array elements\r\n * @description Cumulative sum of array elements\r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number} dim dimension selected, 1: column 0: row (def: 1)\r\n * @return {array|matrix}   \r\n *\r\n * @example\r\n * ubique.cumsum([5,6,3]);\r\n * // [5, 11, 14]\r\n * \r\n * ubique.cumsum([[5,6,5],[7,8,-1]]);\r\n * // [ [ 5, 6, 5 ], [ 12, 14, 4 ] ]\r\n * \r\n * ubique.cumsum([[5,6,5],[7,8,-1]],0);\r\n * // [ [ 5, 11, 16 ], [ 7, 15, 14 ] ]\r\n */\r\n $u.cumsum = function(x,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim = dim == null ? 1 : dim;\r\n  var _cumsum =  function(a) {\r\n    var v = [];\r\n    v[0] = a[0];\r\n    for (var i = 1;i < a.length;i++) {\r\n      v[i] = v[i - 1] + a[i];\r\n    }\r\n    return v;\r\n  }\r\n  return $u.vectorfun(dim,x,_cumsum);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/diff.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method diff\r\n * @summary Differences between adjacent elements in array \r\n * @description Differences between adjacent elements in array or matrix \r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} dim dimension selected, 1: column 0: row (def: 1)\r\n * @return {array|matrix}   \r\n *\r\n * @example\r\n * ubique.diff([5,6,3]);\r\n * // [1, -3]\r\n * \r\n * ubique.diff([[5,6,5],[7,8,-1]]);\r\n * // [ [ 2, 2, -6 ] ]\r\n * \r\n * ubique.diff([[5,6,5],[7,8,-1]],0);\r\n * // [ [ 1, -1 ], [ 1, -9 ] ]\r\n */\r\n $u.diff = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n   dim = dim == null ? 1 : dim;\r\n   var _diff =  function(a) {\r\n    var v = [];\r\n     for (var i = 1;i < a.length;i++) {\r\n      v[i - 1] = a[i] - a[i - 1];\r\n    }\r\n    return v;\r\n  }\r\n  return $u.vectorfun(dim,x,_diff);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/dot.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method dot\r\n * @summary Arrays dot product X * Y\r\n * @description Arrays dot product X * Y. X and Y must be arrays of the same length\r\n * \r\n * @param  {array} x number or array of values\r\n * @param  {array} y number or array of values\r\n * @return {array}   \r\n *\r\n * @example\r\n * ubique.dot([5,6,3],[0.5,-3,2.3]);\r\n * // -8.6\r\n */\r\n $u.dot = function(x,y) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n    if ($u.size(x)[0] !== $u.size(y)[0] || $u.size(x)[1] !== $u.size(y)[1]) {\r\n    \tthrow new Error('input size mismatch');\r\n    }\r\n    return $u.sum($u.times(x,y));\r\n }\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/eq.js":"/**\r\n * Relational Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method eq\r\n * @summary Equality X === Y\r\n * @description Equality X === Y\r\n *\r\n * @param  {number|array|matrix} x left array\r\n * @param  {number|array|matrix} y right array\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.eq(5,5);\r\n * // true\r\n * \r\n * ubique.eq(5,[5,6,3]);\r\n * // [ true, false, false ]\r\n * \r\n * ubique.eq(5,[[5,6],[3,5]]);\r\n * // [ [ true, false ], [ false, true ] ]\r\n * \r\n * ubique.eq([5,6,3],5);\r\n * // [ true, false, false ]\r\n * \r\n * ubique.eq([[5,6],[3,5]],5);\r\n * // [ [ true, false ], [ false, true ] ]\r\n * \r\n * ubique.eq([5,6,3],[2,6,0]);\r\n * // [ false, true, false ]\r\n * \r\n * ubique.eq([[5,6],[-1,2]],[[5,6],[3,5]]);\r\n * // [ [ true, true ], [ false, false ] ]\r\n */\r\n $u.eq = function(x,y) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _eq = function(el) {\r\n    return el === 0;\r\n  }\r\n  var d = $u.minus(x,y);\r\n  return $u.arrayfun(d,_eq);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/floor.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n \t/**\r\n * @method floor\r\n * @summary Round toward negative infinity\r\n * @description Round toward negative infinity\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @param  {number} x number of decimals\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.floor(Math.PI,12);\r\n * // 3.141592653589\r\n * \r\n * ubique.floor(3.78);\r\n * // 3\r\n * \r\n * ubique.floor([4.51,-1.4]);\r\n * // [ 4, -2 ]\r\n * \r\n * ubique.floor([[4.5134,-1.4345],[3.7809,0.0134]],2);\r\n * //[ [ 4.51, -1.43 ], [ 3.78, 0.01 ] ]\r\n */\r\n $u.floor = function(x,n) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  n = n == null ? 0 : n;\r\n  var p = Math.pow(10,n);\r\n  var _floor = function(a) {\r\n    return Math.round(a * p) / p;\r\n  }\r\n  return $u.arrayfun(x,_floor);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/ge.js":"/**\r\n * Relational Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method ge\r\n * @summary Greater than or equal to X >= Y\r\n * @description Greater than or equal to X >= Y\r\n *\r\n * @param  {number|array|matrix} x left array\r\n * @param  {number|array|matrix} y right array\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.ge(5,5);\r\n * // true\r\n * \r\n * ubique.ge(5,[5,6,3]);\r\n * // [ true, false, true ]\r\n * \r\n * ubique.ge(5,[[5,6],[3,5]]);\r\n * // [ [ true, false ], [ false, true ] ]\r\n * \r\n * ubique.ge([5,6,3],5);\r\n * // [ true, true, false ]\r\n * \r\n * ubique.ge([[5,6],[3,5]],5);\r\n * // [ [ true, true ], [ false, true ] ]\r\n * \r\n * ubique.ge([5,6,3],[2,6,0]);\r\n * // [ false, true, false ]\r\n * \r\n * ubique.ge([[5,6],[-1,2]],[[5,6],[3,5]]);\r\n * // [ [ true, true ], [ false, false ] ]\r\n */\r\n $u.ge = function(x,y) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _ge = function(el) {\r\n    return el >= 0;\r\n  }\r\n  var d = $u.minus(x,y);\r\n  return $u.arrayfun(d,_ge);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/gt.js":"/**\r\n * Relational Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method gt\r\n * @summary Greater than X > Y\r\n * @description Greater than X > Y\r\n *\r\n * @param  {number|array|matrix} x left array\r\n * @param  {number|array|matrix} y right array\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.gt(5,5);\r\n * // false\r\n * \r\n * ubique.gt(5,[5,6,3]);\r\n * // [ false, false, true ]\r\n * \r\n * ubique.gt(5,[[5,6],[3,5]]);\r\n * // [ [ false, false ], [ true, false ] ]\r\n * \r\n * ubique.gt([5,6,3],5);\r\n * // [ false, true, false ]\r\n * \r\n * ubique.gt([[5,6],[3,5]],5);\r\n * // [ [ false, true ], [ false, false ] ]\r\n * \r\n * ubique.gt([5,6,3],[2,6,0]);\r\n * // [ true, false, true ]\r\n * \r\n * ubique.gt([[5,6],[-1,2]],[[5,6],[3,5]]);\r\n * // [ [ false, false ], [ false, false ] ]\r\n */\r\n $u.gt = function(x,y) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _gt = function(el) {\r\n    return el > 0;\r\n  }\r\n  var d = $u.minus(x,y);\r\n  return $u.arrayfun(d,_gt);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/ldivide.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method ldivide\r\n * @summary Left array division X. \\ Y\r\n * @description Divides each element of Y by the corresponding element of X. Inputs X and Y\r\n * must have the same size\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @param  {number|array|matrix} y number or array of values\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * ubique.ldivide(5,6);\r\n * // 1.2\r\n * \r\n * ubique.ldivide([5,6,7],3);\r\n * // [ 0.6, 0.5, 0.428571 ]\r\n * \r\n * ubique.ldivide(3,[-1,-2,-3]);\r\n * // [ -0.333333, -0.666667, -1 ]\r\n * \r\n * ubique.ldivide([5,6,3],[0.5,-3,2.3]);\r\n * // [ 0.1, -0.5, 0.766667 ]\r\n * \r\n * ubique.ldivide([[9, 5], [6, 1]],[[3, 2], [5, 2]]);\r\n * // [ [ 0.333333, 0.4 ], [ 0.833333, 2 ] ]\r\n * \r\n * ubique.ldivide([[9, 5], [6, 1]],3);\r\n * // [ [ 0.333333, 0.6 ], [ 0.5, 3 ] ]\r\n */\r\n $u.ldivide = function(y,x) {\r\n \tif (arguments.length < 2) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\tif ($u.isnumber(y)) {\r\n \t\t\treturn x / y;\r\n \t\t}\r\n \t\tif ($u.ismatrix(y)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(y);i++) {\r\n \t\t\t\tvar vec = $u.getrow(y,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return x / val;});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(y,function(val){return x / val;})\r\n \t}\r\n \tif ($u.isnumber(y)) {\r\n \t\tif ($u.ismatrix(x)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(x);i++) {\r\n \t\t\t\tvar vec = $u.getrow(x,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return val / y;});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(x,function(val){return val / y;})\r\n \t}\r\n \tif ($u.isarray(x) && $u.isarray(y)) {\r\n \t\tvar v = [];\r\n \t\tfor (var i = 0;i < x.length;i++) {\r\n \t\t\tv[i] = x[i] / y[i];\r\n \t\t}\r\n \t\treturn v;\r\n \t}\r\n \tif ($u.ismatrix(x) && $u.ismatrix(y)) {\r\n \t\tvar v = [];\r\n \t\tfor (var i = 0;i < $u.nrows(x);i++) {\r\n \t\t\tvar vx = $u.getrow(x,i),\r\n \t\t\tvy = $u.getrow(y,i);\r\n \t\t\tv[i] = $u.rdivide(vx,vy);\r\n \t\t}\r\n \t\treturn v;\r\n \t}\r\n }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/le.js":"/**\r\n * Relational Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method le\r\n * @summary Less than or equal to X <= Y\r\n * @description Less than or equal to X <= Y\r\n *\r\n * @param  {number|array|matrix} x left array\r\n * @param  {number|array|matrix} y right array\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.le(5,5);\r\n * // true\r\n * \r\n * ubique.le(5,[5,6,3]);\r\n * // [ true, true, false ]\r\n * \r\n * ubique.le(5,[[5,6],[3,5]]);\r\n * // [ [ true, true ], [ false, true ] ]\r\n * \r\n * ubique.le([5,6,3],5);\r\n * // [ true, false, true ]\r\n * \r\n * ubique.le([[5,6],[3,5]],5);\r\n * // [ [ true, false ], [ true, true ] ]\r\n * \r\n * ubique.le([5,6,3],[2,6,0]);\r\n * // [ false, true, false ]\r\n * \r\n * ubique.le([[5,6],[-1,2]],[[5,6],[3,5]]);\r\n * // [ [ true, true ], [ true, true ] ]\r\n */\r\n $u.le = function(x,y) {\r\n  if (arguments.lenleh < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _le = function(el){\r\n    return el <= 0;\r\n  }\r\n  var d = $u.minus(x,y);\r\n  return $u.arrayfun(d,_le);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/lt.js":"/**\r\n * Relational Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method lt\r\n * @summary Less than X < Y\r\n * @description Less than X < Y\r\n *\r\n * @param  {number|array|matrix} x left array\r\n * @param  {number|array|matrix} y right array\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.lt(5,5);\r\n * // false\r\n * \r\n * ubique.lt(5,[5,6,3]);\r\n * // [ false, true, false ]\r\n * \r\n * ubique.lt(5,[[5,6],[3,5]]);\r\n * // [ [ false, true ], [ false, false ] ]\r\n * \r\n * ubique.lt([5,6,3],5);\r\n * // [ false, false, true ]\r\n * \r\n * ubique.lt([[5,6],[3,5]],5);\r\n * // [ [ false, false ], [ true, false ] ]\r\n * \r\n * ubique.lt([5,6,3],[2,6,0]);\r\n * // [ false, false, false ]\r\n * \r\n * ubique.lt([[5,6],[-1,2]],[[5,6],[3,5]]);\r\n * // [ [ false, false ], [ true, true ] ]\r\n */\r\n $u.lt = function(x,y) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _lt = function(el){ \r\n    return el < 0;\r\n  }\r\n  var d = $u.minus(x,y);\r\n  return $u.arrayfun(d,_lt);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/minus.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method minus\r\n * @summary Subtraction X - Y\r\n * @description Subtraction X - Y. X and Y must have the same dimension unless one is a number\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @param  {number|array|matrix} y number or array of values\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * ubique.minus(5,6);\r\n * // -1\r\n * \r\n * ubique.minus([5,6,4],[3,-1,0]);\r\n * // [ 2, 7, 4 ]\r\n * \r\n * ubique.minus([5,6,4],10);\r\n * // [-5, -4, -6]\r\n * \r\n * ubique.minus([[5,6,5],[7,8,-1]],[[-1,3,-1],[4,5,9]]);\r\n * // [[ 6, 3, 6 ], [ 3, 3, -10 ]]\r\n */\r\n $u.minus = function(x,y) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\tif ($u.isnumber(y)) {\r\n \t\t\treturn x - y;\r\n \t\t}\r\n \t\tif ($u.ismatrix(y)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(y);i++) {\r\n \t\t\t\tvar vec = $u.getrow(y,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return x - val;});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(y,function(val){return x - val;})\r\n \t}\r\n \tif ($u.isnumber(y)) {\r\n \t\tif ($u.ismatrix(x)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(x);i++) {\r\n \t\t\t\tvar vec = $u.getrow(x,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return val - y;});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(x,function(val){return val - y;})\r\n \t}\r\n \tif ($u.isarray(x) && $u.isarray(y)) {\r\n \t\tvar v = [];\r\n \t\tfor (var i = 0;i < x.length;i++) {\r\n \t\t\tv[i] = x[i] - y[i];\r\n \t\t}\r\n \t\treturn v;\r\n \t}\r\n \tif ($u.ismatrix(x) && $u.ismatrix(y)) {\r\n    if (($u.nrows(x) === $u.nrows(y)) && ($u.ncols(x) === $u.ncols(y))) {\r\n     var v = [];\r\n     for (var i = 0;i < $u.nrows(x);i++) {\r\n      var vx = $u.getrow(x,i),\r\n      vy = $u.getrow(y,i);\r\n      v[i] = $u.minus(vx,vy);\r\n    }\r\n    return v;\r\n  } else {\r\n    throw new Error('input dimensions must agree');\r\n  }\r\n}\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/mldivide.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n  /**\r\n  * @method mldivide\r\n  * @summary Matrix division X \\ Y\r\n  * @description Matrix division X \\ Y. If X is NxN and Y is NxM, then\r\n  * returns a matrix NxM. Y is multiplied with the inverse of X. X must be square.\r\n  * \r\n  * @param  {number|array|matrix} x number or array of values\r\n  * @param  {number|array|matrix} y number or array of values\r\n  * @return {number|array|matrix}   \r\n  *\r\n  * @example \r\n  * ubique.mldivide(5,6);\r\n  * // 1.2\r\n  * \r\n  * ubique.mldivide([[9, 5],[6, 1]],[[3, 2],[5, 2]]);\r\n  * // [ [ 1.047619, 0.380952 ], [ -1.285714, -0.285714 ] ]\r\n  * \r\n  * ubique.mldivide(5,[[9, 5],[6, 1]]);\r\n  * // [ [ 1.8, 1 ], [ 1.2, 0.2 ] ]\r\n  * \r\n  * ubique.mldivide([[9, 5],[6, 1]],[[5,6,5],[7,8,-1]]);\r\n  * // [ [ 1.428571, 1.619048, -0.47619 ],[ -1.571429, -1.714286, 1.857143 ] ]\r\n  */\r\n  $u.mldivide = function(y,x) {\r\n    if (arguments.length < 2) {\r\n      throw new Error('not enough input arguments');\r\n    }\r\n    if ($u.isnumber(x) && $u.isnumber(y)) {\r\n      return x/y;\r\n    } else\r\n    if ($u.isnumber(y)) {\r\n      return $u.ldivide(y,x);\r\n    } else \r\n    if ($u.issquare(y)) {\r\n      if ($u.ncols(y) !== $u.nrows(x)) {\r\n        throw new Error('matrix dimensions mismatch');\r\n      }\r\n      return $u.mtimes($u.inv(y),x);\r\n    } else {\r\n      throw new Error('first argument must be square');\r\n    }\r\n  }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/mod.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method mod\r\n * @summary Modulus after division\r\n * @description Modulus after division. Element-wise for matrix\r\n * \r\n * @param  {number|array|matrix} x dividend\r\n * @param  {number|array|matrix} y divisor\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * var b = [[-1,3,-1],[4,5,9]];\r\n * \r\n * ubique.mod([13,-7],2.2);\r\n * // [ 2, 1.8 ]\r\n * \r\n * ubique.mod([13,-7],[5,6]);\r\n * // [ 3, 5 ]\r\n * \r\n * ubique.mod(a,b);\r\n * // [[ 0, 0, 0 ], [ 3, 3, 8 ]]\r\n */\r\n $u.mod = function(x,y) {\r\n \tif (arguments.length < 2) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tvar n = $u.floor($u.rdivide(x,y));\r\n \treturn $u.minus(x,$u.times(n,y));\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/mpower.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method mpower\r\n * @summary Matrix power X ^ Y\r\n * @description Matrix power X ^ Y. X is the square input matrix and y is the scalar exponent.\r\n * \r\n * @param  {matrix} x base \r\n * @param  {number} y exponent \r\n * @return {matrix}   \r\n *\r\n * @example\r\n * ubique.mpower([[1,1,-1],[1,-2,3],[2,3,1]],3);\r\n * // [ [ -2, 11, -11 ], [ 11, -35, 33 ], [ 22, 33, -2 ] ]\r\n */\r\n $u.mpower = function(x,y) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif (!$u.issquare(x)) {\r\n \t\tthrow new Error('input must be a square matrix');\r\n \t}\r\n \tif (!$u.isnumber(y)) {\r\n \t\tthrow new Error('exponent must be a scalar value');\r\n \t}\r\n \tvar out = x,\r\n \tt = 1;\r\n \twhile (t < y) {\r\n \t\tout = $u.mtimes(x,out);\r\n \t\tt++;\r\n \t}\r\n \treturn out;\r\n }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/mrdivide.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n  /**\r\n  * @method mrdivide\r\n  * @summary Matrix division X / Y\r\n  * @description Matrix division X / Y. If X is MxN and Y is NxN, then\r\n  * it returns a matrix MxN. X is multiplied with the inverse of Y. Y must be square.\r\n  * \r\n  * @param  {number|array|matrix} x number or array of values\r\n  * @param  {number|array|matrix} y number or array of values\r\n  * @return {number|array|matrix}   \r\n  *\r\n  * @example\r\n  * ubique.mrdivide(5,6);\r\n  * // 0.833333\r\n  * \r\n  * ubique.mrdivide([5,6,3],6);\r\n  * // [ 0.833333, 1, 0.5 ]\r\n  * \r\n  * ubique.mrdivide([[9, 5], [6, 1]],5);\r\n  * // [ [ 1.8, 1 ], [ 1.2, 0.2 ] ]\r\n  * \r\n  * ubique.mrdivide([[9, 5], [6, 1]],[[3, 2], [5, 2]]);\r\n  * // [ [ 1.75, 0.75 ], [ -1.75, 2.25 ] ]\r\n  * \r\n  * ubique.mrdivide([[5,6,5],[7,8,-1]],[[1,1,-1],[1,-2,3],[2,3,1]]);\r\n  * // [ [ -0.769231, 0.538462, 2.615385 ],[ 3.384615, 0.230769, 1.692308 ] ]\r\n  */\r\n  $u.mrdivide = function(x,y) {\r\n    if (arguments.length < 2) {\r\n      throw new Error('not enough input arguments');\r\n    }\r\n    if ($u.isnumber(x) && $u.isnumber(y)) {\r\n      return x/y;\r\n    } else\r\n    if ($u.isnumber(y)) {\r\n      return $u.rdivide(x,y);\r\n    } else \r\n    if ($u.issquare(y)) {\r\n      if ($u.ncols(x) !== $u.nrows(y)) {\r\n        throw new Error('matrix dimensions mismatch');\r\n      }\r\n      return $u.mtimes(x,$u.inv(y));\r\n    } else {\r\n      throw new Error('second argument must be square');\r\n    }\r\n  }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/mtimes.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method mtimes\r\n * @summary Matrix multiplication X * Y\r\n * @description  Matrix multiplication X * Y. If X is MxP and Y is PxN, returns a matrix MxN\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @param  {number|array|matrix} y number or array of values\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * ubique.mtimes(5,6);\r\n * // 30\r\n * \r\n * ubique.mtimes([5,6,3],3);\r\n * // [ 15, 18, 9 ]\r\n * \r\n * ubique.mtimes([[5,6,5],[7,8,-1]],3);\r\n * // [ [ 15, 18, 15 ], [ 21, 24, -3 ] ]\r\n * \r\n * ubique.mtimes([[5,6,3]],[[3],[4],[5]]);\r\n * // [ [ 54 ] ]\r\n * \r\n * ubique.mtimes([[5,6,5],[7,8,-1]],[[5],[6],[3]]);\r\n * // [ [ 76 ], [ 80 ] ]\r\n */\r\n $u.mtimes = function(x,y) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif (!$u.isnumber(x) && !$u.isnumber(y)) {\r\n \t\tvar xsize = $u.size(x);\r\n \t\tvar ysize = $u.size(y);\r\n \t\tif (xsize[1] !== ysize[0]) {\r\n \t\t\tthrow new Error('inner dimension mismatch');\r\n \t\t}\r\n \t\tvar out = $u.matrix(xsize[0],ysize[1]);\r\n \t\tfor (var i = 0;i < xsize[0];i++) {\r\n \t\t\tvar xx = $u.getrow(x,i);\r\n \t\t\tfor (var j = 0;j < ysize[1];j++) {\r\n \t\t\t\tvar yy = $u.getcol(y,j);\r\n \t\t\t\tout[i][j] = $u.squeeze($u.dot(xx,yy));\r\n \t\t\t}\r\n \t\t}\r\n \t\treturn out;\r\n \t}\r\n \treturn $u.times(x,y);\r\n }\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/ne.js":"/**\r\n * Relational Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method ne\r\n * @summary Inequality X !== Y\r\n * @description Inequality X !== Y\r\n *\r\n * @param  {number|array|matrix} x left array\r\n * @param  {number|array|matrix} y right array\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.ne(5,5);\r\n * // false\r\n * \r\n * ubique.ne(5,[5,6,3]);\r\n * // [ false, true, true ]\r\n * \r\n * ubique.ne(5,[[5,6],[3,5]]);\r\n * // [ [ false, true ], [ true, false ] ]\r\n * \r\n * ubique.ne([5,6,3],5);\r\n * // [ false, true, true ]\r\n * \r\n * ubique.ne([[5,6],[3,5]],5);\r\n * // [ [ false, true ], [ true, false ] ]\r\n * \r\n * ubique.ne([5,6,3],[2,6,0]);\r\n * // [ true, false, true ]\r\n * \r\n * ubique.ne([[5,6],[-1,2]],[[5,6],[3,5]]);\r\n * // [ [ false, false ], [ true, true ] ]\r\n */\r\n $u.ne = function(x,y) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _ne = function(el) { \r\n    return el !== 0;\r\n  }\r\n  var d = $u.minus(x,y);\r\n  return $u.arrayfun(d,_ne);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/plus.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method plus\r\n * @summary Addition X + Y\r\n * @description Addition X + Y\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @param  {number|array|matrix} y number or array of values\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * var b = [[-1,3,-1],[4,5,9]];\r\n * \r\n * ubique.plus(5,6);\r\n * // 11\r\n * \r\n * ubique.plus([5,6,4],[3,-1,0]);\r\n * // [ 8, 5, 4 ]\r\n * \r\n * ubique.plus([5,6,4],10);\r\n * // [ 15, 16, 14 ]\r\n * \r\n * ubique.plus(a,b);\r\n * // [[ 4, 9, 4 ], [ 11, 13, 8 ]]\r\n */\r\n $u.plus = function(x,y) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\tif ($u.isnumber(y)) {\r\n \t\t\treturn x + y;\r\n \t\t}\r\n \t\tif ($u.ismatrix(y)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(y);i++) {\r\n \t\t\t\tvar vec = $u.getrow(y,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return x + val;});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(y,function(val){return x + val;})\r\n \t}\r\n \tif ($u.isnumber(y)) {\r\n \t\tif ($u.ismatrix(x)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(x);i++) {\r\n \t\t\t\tvar vec = $u.getrow(x,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return val + y;});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(x,function(val){return val + y;})\r\n \t}\r\n \tif ($u.isarray(x) && $u.isarray(y)) {\r\n \t\tvar v = [];\r\n \t\tfor (var i = 0;i < x.length;i++) {\r\n \t\t\tv[i] = x[i] + y[i];\r\n \t\t}\r\n \t\treturn v;\r\n \t}\r\n \tif ($u.ismatrix(x) && $u.ismatrix(y)) {\r\n     if (($u.nrows(x) === $u.nrows(y)) && ($u.ncols(x) === $u.ncols(y))) {\r\n       var v = [];\r\n       for (var i = 0;i < $u.nrows(x);i++) {\r\n        var vx = $u.getrow(x,i),\r\n        vy = $u.getrow(y,i);\r\n        v[i] = $u.plus(vx,vy);\r\n      }\r\n      return v;\r\n    } else {\r\n      throw new Error('input dimensions must agree');\r\n    }\r\n  }\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/power.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method power\r\n * @summary Element-wise power X. ^ Y\r\n * @description Element-wise power X. ^ Y\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @param  {number|array|matrix} y number or array of values\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * var b = [[-1,3,-1],[4,5,9]];\r\n * var c = [5,6,3];\r\n * var d = [0.5,-3,2.3];\r\n * \r\n * ubique.power(5,4);\r\n * // 625\r\n * \r\n * ubique.power(c,5);\r\n * // [ 3125, 7776, 243 ]\r\n * \r\n * ubique.power(5,c);\r\n * // [ 3125, 15625, 125 ]\r\n * \r\n * ubique.power(a,5);\r\n * // [[ 3125, 7776, 3125 ], [ 16807, 32768, -1 ]]\r\n * \r\n * ubique.power(5,a);\r\n * // [[ 3125, 15625, 3125 ], [ 78125, 3.90625e+5, 0.2 ]]\r\n * \r\n * ubique.power(c,d);\r\n * // [ 2.23607, 0.00462963, 12.5135 ]\r\n * \r\n * ubique.power(a,b);\r\n * // [[ 0.2, 216, 0.2 ], [ 2401, 32768, -1 ]]\r\n */\r\n $u.power = function(x,y) {\r\n \tif (arguments.length < 2) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\tif ($u.isnumber(y)) {\r\n \t\t\treturn Math.pow(x,y);\r\n \t\t}\r\n \t\tif ($u.ismatrix(y)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(y);i++) {\r\n \t\t\t\tvar vec = $u.getrow(y,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return Math.pow(x,val);});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(y,function(val){return Math.pow(x,val);})\r\n \t}\r\n \tif ($u.isnumber(y)) {\r\n \t\tif ($u.ismatrix(x)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(x);i++) {\r\n \t\t\t\tvar vec = $u.getrow(x,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return Math.pow(val,y);});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(x,function(val){return Math.pow(val,y);})\r\n \t}\r\n \tif ($u.isarray(x) && $u.isarray(y)) {\r\n \t\tvar v = [];\r\n \t\tfor (var i = 0;i < x.length;i++) {\r\n \t\t\tv[i] = Math.pow(x[i],y[i]);\r\n \t\t}\r\n \t\treturn v;\r\n \t}\r\n \tif ($u.ismatrix(x) && $u.ismatrix(y)) {\r\n \t\tvar v = [];\r\n \t\tfor (var i = 0;i < $u.nrows(x);i++) {\r\n \t\t\tvar vx = $u.getrow(x,i),\r\n \t\t\tvy = $u.getrow(y,i);\r\n \t\t\tv[i] = $u.power(vx,vy);\r\n \t\t}\r\n \t\treturn v;\r\n \t}\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/prod.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method prod\r\n * @summary Product of array elements\r\n * @description Product of array elements\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} dim dimension, 1: column 0: row (def: 1)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * ubique.prod([5,6,3]);\r\n * // 90\r\n * \r\n * ubique.prod([[5,6,5],[7,8,-1]],0);\r\n * // [ [ 150 ], [ -56 ] ]\r\n * \r\n * ubique.prod([[5,6,5],[7,8,-1]],1);\r\n * // [ [ 35, 48, -5 ] ]\r\n */\r\n $u.prod = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  dim = dim == null ? 1 : dim;\r\n  var _prod = function(a) {\r\n    var prod = 1;\r\n    for (var i = 0;i < a.length;i++) {\r\n      prod *= a[i];\r\n    }\r\n    return prod;\r\n  }\r\n  return $u.vectorfun(dim,x,_prod);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/rdivide.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method rdivide\r\n * @summary Right array division X. / Y\r\n * @description Divides each element of X by the corresponding element of Y. Inputs X and Y\r\n * must have the same size\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @param  {number|array|matrix} y number or array of values\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * var b = [-1,-2,-3];\r\n * var e = [[9, 5], [6, 1]];\r\n * var f = [[3, 2], [5, 2]];\r\n * \r\n * ubique.rdivide(5,6);\r\n * // 0.833333\r\n * \r\n * ubique.rdivide(a,3);\r\n * // [[ 1.66667, 2, 1.66667 ], [ 2.33333, 2.66667, -0.333333 ]]\r\n * \r\n * ubique.rdivide(3,[-1,-2,-3]);\r\n * // [ -3, -1.5, -1 ]\r\n * \r\n * ubique.rdivide([5,6,7],[-1,-2,-3]);\r\n * // [ -5, -3, -2.33333 ]\r\n * \r\n * ubique.rdivide(e,f);\r\n * // [[ 3, 2.5 ], [ 1.2, 0.5 ]]\r\n * \r\n * ubique.rdivide(e,3);\r\n * // [[ 3, 1.66667 ], [ 2, 0.333333 ]]\r\n */\r\n $u.rdivide = function(x,y) {\r\n \tif (arguments.length < 2) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\tif ($u.isnumber(y)) {\r\n \t\t\treturn x / y;\r\n \t\t}\r\n \t\tif ($u.ismatrix(y)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(y);i++) {\r\n \t\t\t\tvar vec = $u.getrow(y,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return x / val;});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(y,function(val){return x / val;})\r\n \t}\r\n \tif ($u.isnumber(y)) {\r\n \t\tif ($u.ismatrix(x)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(x);i++) {\r\n \t\t\t\tvar vec = $u.getrow(x,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return val / y;});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(x,function(val){return val / y;})\r\n \t}\r\n \tif ($u.isarray(x) && $u.isarray(y)) {\r\n \t\tvar v = [];\r\n \t\tfor (var i = 0;i < x.length;i++) {\r\n \t\t\tv[i] = x[i] / y[i];\r\n \t\t}\r\n \t\treturn v;\r\n \t}\r\n \tif ($u.ismatrix(x) && $u.ismatrix(y)) {\r\n \t\tvar v = [];\r\n \t\tfor (var i = 0;i < $u.nrows(x);i++) {\r\n \t\t\tvar vx = $u.getrow(x,i),\r\n \t\t\tvy = $u.getrow(y,i);\r\n \t\t\tv[i] = $u.rdivide(vx,vy);\r\n \t\t}\r\n \t\treturn v;\r\n \t}\r\n }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/rem.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method rem\r\n * @summary Remainder after division\r\n * @description Remainder after division. Element-wise for matrix\r\n * \r\n * @param  {number|array|matrix} x dividend\r\n * @param  {number|array|matrix} y divisor\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * ubique.rem([13,-7],2.2);\r\n * // [ 2, -0.4 ]\r\n * \r\n * ubique.rem([13,-7],[5,6]);\r\n * // [ 3, -1 ]\r\n * \r\n * ubique.rem([[5,6,5],[7,8,-1]],[[-1,3,-1],[4,5,9]]);\r\n * // [ [ 0, 0, 0 ], [ 3, 3, -1 ] ]\r\n */\r\n $u.rem = function(x,y) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tvar n = $u.fix($u.rdivide(x,y));\r\n \treturn $u.minus(x,$u.times(n,y));\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/round.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n \t/**\r\n * @method round\r\n * @summary Round to nearest integer\r\n * @description Round to nearest integer. Element-wise for matrix\r\n * \r\n * @param  {number|array|matrix} x values\r\n * @param  {number} n number of decimal (def: 0)\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * ubique.round(Math.PI,12);\r\n * // 3.14159265359\r\n * \r\n * ubique.round([-1.4543,4.5234],2);\r\n * // [ -1.45, 4.52 ]\r\n * \r\n * ubique.round([-1.9,-0.2,3.4,5.6,7.0]);\r\n * // [ -2, -0, 3, 6, 7 ]\r\n * \r\n * ubique.round([[1.45,-2.3],[1.1,-4.3]]);\r\n * // [ [ 1, -2 ], [ 1, -4 ] ]\r\n */\r\n $u.round = function(x,n) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tn = n == null ? 0 : n;\r\n \tvar p = Math.pow(10,n);\r\n \tvar _round = function(a) {\r\n    return Math.round(a * p) / p;\r\n  }\r\n  return $u.arrayfun(x,_round);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/sum.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method sum\r\n * @summary Sum of array elements\r\n * @description Sum of array elements\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} dim dimension, 1: column 0: row (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * ubique.sum([5,6,3]);\r\n * // 14\r\n * \r\n * ubique.sum([[5,6,5],[7,8,-1]],0);\r\n * // [ [ 16 ], [ 14 ] ]\r\n * \r\n * ubique.sum([[5,6,5],[7,8,-1]],1);\r\n * // [ [ 12, 14, 4 ] ]\r\n */\r\n $u.sum = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tdim = dim == null ? 0 : dim;\r\n \tvar _sum = function(a) {\r\n \t\tvar sum = 0;\r\n \t\tfor (var i = 0;i < a.length;i++) {\r\n \t\t\tsum += a[i];\r\n \t\t}\r\n \t\treturn sum;\r\n \t}\r\n \treturn $u.vectorfun(dim,x,_sum);\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/times.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method times\r\n * @summary Array multiply X. * Y\r\n * @description  Element-by-element multiplication. X and Y must have the same dimensions unless ones is a number\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @param  {number|array|matrix} y number or array of values\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * ubique.times(5,6);\r\n * // 30\r\n * \r\n * ubique.times([5,6,4],[3,-1,0]);\r\n * // [ 15, -6, 0 ]\r\n * \r\n * ubique.times([5,6,4],10);\r\n * // [ 50, 60, 40 ]\r\n * \r\n * ubique.times([[5,6,5],[7,8,-1]],[[-1,3,-1],[4,5,9]]);\r\n * // [ [ -5, 18, -5 ], [ 28, 40, -9 ] ]\r\n */\r\n $u.times = function(x,y) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\tif ($u.isnumber(y)) {\r\n \t\t\treturn x * y;\r\n \t\t}\r\n \t\tif ($u.ismatrix(y)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(y);i++) {\r\n \t\t\t\tvar vec = $u.getrow(y,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return x * val;});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(y,function(val){return x * val;})\r\n \t} else\r\n \tif ($u.isnumber(y)) {\r\n \t\tif ($u.ismatrix(x)) {\r\n \t\t\tvar v = [];\r\n \t\t\tfor (var i = 0;i < $u.nrows(x);i++) {\r\n \t\t\t\tvar vec = $u.getrow(x,i);\r\n \t\t\t\tv[i] = $u.arrayfun(vec,function(val){return val * y;});\r\n \t\t\t}\r\n \t\t\treturn v;\r\n \t\t}\r\n \t\treturn $u.arrayfun(x,function(val){return val * y;})\r\n \t} else\r\n \tif ($u.isarray(x) && $u.isarray(y)) {\r\n \t\tvar v = [];\r\n \t\tfor (var i = 0;i < x.length;i++) {\r\n \t\t\tv[i] = x[i] * y[i];\r\n \t\t}\r\n \t\treturn v;\r\n \t} else\r\n \tif ($u.ismatrix(x) && $u.ismatrix(y)) {\r\n \t\tvar v = [];\r\n \t\tfor (var i = 0;i < $u.nrows(x);i++) {\r\n \t\t\tvar vx = $u.getrow(x,i),\r\n \t\t\tvy = $u.getrow(y,i);\r\n \t\t\tv[i] = $u.times(vx,vy);\r\n \t\t}\r\n \t\treturn v;\r\n \t} else {\r\n \t\tthrow new Error('unknown input arguments');\r\n \t}\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/uminus.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method uminus\r\n * @summary Unary minus -X\r\n * @description Unary minus -X\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.uminus(-5);\r\n * // 5\r\n * \r\n * ubique.uminus([5,6]);\r\n * // [ -5, -6 ]\r\n * \r\n * ubique.uminus([[5,6],[-1,-3]]);\r\n * // [ [ -5, -6 ], [ 1, 3 ] ]\r\n */\r\n $u.uminus = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  return $u.arrayfun(x,function(a){return -1 * a;});\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elemop/unique.js":"/**\r\n * Set Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method unique\r\n * @summary Unique values in array or matrix\r\n * @description Unique values in array or matrix. Use mergsort to sort values, returns\r\n * a matrix with 2 array, the unique values and the unique indexes.\r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {boolean} flag flag 0: export unique values, 1: export values and indexes(def: 0)\r\n * @return {array|matrix}\r\n *\r\n * @example\r\n * ubique.unique([9,-3,2,-12,0,1,0,1,2,3,4,5]);\r\n * // [ -3, -3, 0, 1, 2, 3, 4, 5, 9 ]\r\n *\r\n * ubique.unique([9,-3,2,-12,0,1,0,1,2,3,4,5],1);\r\n * // [ [ -3, -3, 0, 1, 2, 3, 4, 5, 9 ], [ 3, 1, 4, 5, 2, 9, 10, 11, 0 ] ]\r\n * \r\n * ubique.unique([[5,4],[5,3],[6,3]]);\r\n * // [ 3, 4, 5, 6 ]\r\n *\r\n * ubique.unique([[5,4],[5,3],[6,3]],1);\r\n * // [ [ 3, 4, 5, 6 ], [ 3, 1, 0, 4 ] ]\r\n */\r\n $u.unique = function(x,flag) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  flag = flag == null ? 0 : flag;\r\n  if ($u.ismatrix) {\r\n    x = $u.flatten(x); // flatten by rows\r\n  }\r\n  var sorted = $u.mergesort(x);\r\n  var uvalue = [sorted[0][1]];\r\n  var uindex = [sorted[1][0]];\r\n\r\n  for (var i = 1;i < sorted[0].length; i++) {\r\n    if (sorted[0][i] !== sorted[0][i - 1]) {\r\n      uvalue.push(sorted[0][i]);\r\n      uindex.push(sorted[1][i]);\r\n    }\r\n  }\r\n  if (flag === 0) {\r\n    return uvalue;\r\n  } else\r\n  if (flag === 1) {\r\n    return [uvalue,uindex];\r\n  } else {\r\n    throw new Error('flag can be only 0 (default) or 1');\r\n  }\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elmath/abs.js":"/**\r\n * Complex Numbers\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method abs\r\n * @summary Absolute value\r\n * @description Absolute value\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * ubique.abs(-0.5);\r\n * // -1\r\n * \r\n * ubique.abs([0.1,-0.5]);\r\n * // [0.1, 0.5]\r\n * \r\n * ubique.abs([[5,-2],[-3,4]]);\r\n * // [[5, 2], [3, 4]]\r\n */\r\n $u.abs = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tvar fun = Math.abs;\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn fun(x);\r\n \t}\r\n \treturn $u.arrayfun(x,fun);\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elmath/erf.js":"/**\r\n * Special Functions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method  erf\r\n * @summary Error function\r\n * @description Error function\r\n * \r\n * Approximation with maximal error 1.2x10^-7\r\n * erf(x) = 2/sqrt(pi) * integral from 0 to x of exp(-t^2) dt\r\n * \r\n * @param  {number} x real value\r\n * @return {number}\r\n * \r\n * @example\r\n * ubique.erf(0.5);\r\n * // 0.5204999077232426\r\n */\r\n $u.erf = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return 1 - $u.erfc(x);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elmath/erfc.js":"/**\r\n * Special Functions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method erfc\r\n * @summary Complementary error function\r\n * @description Complementary error function\r\n *\r\n * erfc(x) = 2/sqrt(pi) * integral from x to inf of exp(-t^2) dt\r\n * erfc(x) = 1 - erf(x)\r\n * \r\n * @param  {number} x must be real\r\n * @return {number}\r\n * \r\n * @example\r\n * ubique.erfc(0.5);\r\n * // 0.47950009227675744\r\n */\r\n $u.erfc = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var z = Math.abs(x),\r\n  t = 1 / (0.5 * z + 1),\r\n  a1 = t * 0.17087277 + -0.82215223,\r\n  a2 = t * a1 + 1.48851587,\r\n  a3 = t * a2 + -1.13520398,\r\n  a4 = t * a3 + 0.27886807,\r\n  a5 = t * a4 + -0.18628806,\r\n  a6 = t * a5 + 0.09678418,\r\n  a7 = t * a6 + 0.37409196,\r\n  a8 = t * a7 + 1.00002368,\r\n  a9 = t * a8,\r\n  a10 = -z * z - 1.26551223 + a9,\r\n  a = t * Math.exp(a10);\r\n\r\n  if (x < 0) {a = 2 - a;}\r\n  return a;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elmath/erfcinv.js":"/**\r\n * Special Functions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method  erfcinv\r\n * @summary Inverse complementary error function\r\n * @description Inverse complementary error function\r\n * \r\n * It satisfies y = erfc(x) for 2 >= y >= 0 with -Inf <= x <= Inf\r\n * \r\n * @param  {number} y real value in range [2,0]\r\n * @return {number}   \r\n *\r\n * @example\r\n * ubique.erfcinv(1.5);\r\n * // -0.476936236121904\r\n */\r\n $u.erfcinv = function(y) {\r\n    if (arguments.length === 0) {\r\n        throw new Error('not enough input arguments');\r\n    }\r\n    if (y >= 2) {return -Infinity;}\r\n    if (y <= 0) {return Infinity;}\r\n    var z = 0,\r\n    _y = (y < 1) ? y : 2 - y,\r\n    t = Math.sqrt(-2 * Math.log(_y / 2));\r\n    x = -0.70711 * ((2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t);\r\n    for (var i = 0; i < 2; i++) {\r\n        z = $u.erfc(x) - _y;\r\n        x += z / (1.12837916709551257 * Math.exp(-x * x) - x * z);\r\n    }\r\n    return (y < 1) ? x : -x;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elmath/erfinv.js":"/**\r\n * Special Functions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method  erfinv\r\n * @summary Inverse error function\r\n * @description Inverse error function\r\n * \r\n * The inverse error function satisfies y = erf(x), for -1 <= y <= 1 and -inf <= x <= inf\r\n * \r\n * @param  {number} y real value in range [-1,1]\r\n * @return {number}   \r\n *\r\n * @example\r\n * ubique.erfinv(0.1);\r\n * // 0.08885596505119545\r\n */\r\n $u.erfinv = function(y) {\r\n    if (arguments.length === 0) {\r\n        throw new Error('not enough input arguments');\r\n    }\r\n    var x,x1,x2,x3,x4,x5,x6,x7,x8,x9,z,z1,z2,z3\r\n    if (y <= -1) {x = -Infinity;return x;}\r\n    else if (y >= 1) {x = Infinity;return x;}\r\n    else if (y < -0.7) {\r\n        z1 = (1 + y) / 2;\r\n        z2 = Math.log(z1) / Math.log(Math.E);\r\n        z3 = Math.sqrt(-z2);\r\n        z = z3;\r\n        x1 = 1.641345311 * z + 3.429567803;\r\n        x2 = x1 * z + -1.624906493;\r\n        x3 = x2 * z + -1.970840454;\r\n        x4 = 1.637067800 * z + 3.543889200;\r\n        x5 = x4 * z + 1;\r\n        x6 = -x3 / x5;\r\n        x = x6;\r\n    } else if (y < 0.7) {\r\n        z = y * y;\r\n        x1 = -0.140543331 * z + 0.914624893;\r\n        x2 = x1 * z + -1.645349621;\r\n        x3 = x2 * z + 0.886226899;\r\n        x4 = 0.012229801 * z + -0.329097515;\r\n        x5 = x4 * z + -0.329097515;\r\n        x6 = x5 * z + 1.442710462;\r\n        x7 = x6 * z + -2.118377725;\r\n        x8 = x7 * z + 1;\r\n        x9 = y * x3 / x8;\r\n        x = x9;\r\n    } else {\r\n        z1 = (1 + y) / 2;\r\n        z2 = Math.log(z1);\r\n        z3 = Math.sqrt(-z2);\r\n        z = z3;\r\n        x1 = 1.641345311 * z + 3.429567803;\r\n        x2 = x1 * z + -1.624906493;\r\n        x3 = x2 * z + -1.970840454;\r\n        x4 = 1.637067800 * z +  3.543889200;\r\n        x5 = x4 * z + 1;\r\n        x6 = x3 / x5;\r\n        x = x6;\r\n    }\r\n    x = x - ($u.erf(x) - y) / (2/Math.sqrt(Math.PI) * Math.exp(-x*x));\r\n    x = x - ($u.erf(x) - y) / (2/Math.sqrt(Math.PI) * Math.exp(-x*x));\r\n\r\n    return x;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elmath/exp.js":"/**\r\n * Exponents and Logarithms\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method exp\r\n * @summary Exponential value\r\n * @description Exponential value\r\n * \r\n * @param  {number|array|matrix} x element\r\n * @return {number|array|matrix}   \r\n *\r\n * @example  \r\n * ubique.exp(6);\r\n * // 403.429\r\n * \r\n * ubique.exp([5,6,3]);\r\n * // [148.413, 403.429, 20.0855]\r\n * \r\n * ubqie.exp([[5,6,5],[7,8,-1]]);\r\n * // [[148.413, 403.429, 148.413], [1096.63, 2980.96, 0.367879]]\r\n */\r\n $u.exp = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tvar fun = Math.exp;\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn fun(x);\r\n \t}\r\n \treturn $u.arrayfun(x,fun)\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elmath/log.js":"/**\r\n * Exponents and Logarithms\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method log\r\n * @summary Natural logarithm\r\n * @description Natural logarithm\r\n * \r\n * @param  {number|array|matrix} x element\r\n * @return {number|array|matrix}   \r\n *\r\n * @example  \r\n * ubique.log(6);\r\n * // 1.79176\r\n * \r\n * ubique.log([5,6,3]);\r\n * // [ 1.60944, 1.79176, 1.09861 ]\r\n * \r\n * ubique.log([[5,6,5],[7,8,2]]);\r\n * // [ [ 1.6094, 1.7918, 1.6094 ], [ 1.9459, 2.0794, 0.6931 ] ]\r\n */\r\n $u.log = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tvar fun = Math.log;\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn fun(x);\r\n \t}\r\n \treturn $u.arrayfun(x,fun)\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elmath/sign.js":"/**\r\n * Complex Numbers\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method sign\r\n * @summary Signum function\r\n * @description Signum function\r\n * \r\n * @param  {number|array|matrix} x element\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * ubique.sign(-0.5);\r\n * // -1\r\n * \r\n * ubique.sign([0.1,-0.5]);\r\n * // [1, -1]\r\n * \r\n * ubique.sign([[5,-2],[-3,4]]);\r\n * // [[1, -1], [-1, 1]]\r\n */\r\n $u.sign = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tvar _sign = function(val) {\r\n \t\tif ($u.isnumber(val)) {\r\n \t\t\tif (val > 0) {\r\n \t\t\t\treturn 1;\r\n \t\t\t} else\r\n \t\t\tif (val < 0) {\r\n \t\t\t\treturn -1;\r\n \t\t\t}\r\n \t\t\treturn 0;\r\n \t\t} else {\r\n \t\t\treturn NaN;\r\n \t\t}\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn _sign(x);\r\n \t}\r\n \treturn $u.arrayfun(x,_sign)\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/elmath/sqrt.js":"/**\r\n * Exponents and Logarithms\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method log\r\n * @summary Square root\r\n * @description Square root\r\n * \r\n * @param  {number|array|matrix} x element\r\n * @return {number|array|matrix}   \r\n *\r\n * @example  \r\n * ubique.sqrt(6);\r\n * // 2.44949\r\n * ubique.sqrt([5,6,3]);\r\n * // [ 2.23607, 2.44949, 1.73205 ]\r\n * ubique.sqrt([[5,6,5],[7,8,2]]);\r\n * // [ [ 2.2361, 2.4495, 2.2361 ], [ 2.6458, 2.8284, 1.4142 ] ]\r\n */\r\n $u.sqrt = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tvar fun = Math.sqrt;\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn fun(x);\r\n \t}\r\n \treturn $u.arrayfun(x,fun)\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/linalgebra/det.js":"/**\r\n * Matrix Analysis\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method det\r\n * @summary Matrix determinant\r\n * @description Matrix determinant with LU decomposition method\r\n *\r\n * @param  {matrix} x square matrix\r\n * @return {number}   \r\n * \r\n * @example\r\n * ubique.det([[1,5],[6,2]]);\r\n * // -28\r\n * \r\n * ubique.det([[2,2],[2,3]]);\r\n * // 2\r\n */\r\n $u.det = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isnumber(x) || $u.isarray(x)) {\r\n \t\tthrow new Error('input must be a matrix');\r\n \t}\r\n \tif (!$u.issquare(x)) {\r\n \t\tthrow new Error('matrix must be square')\r\n \t}\r\n \tif ($u.issingular(x)) {\r\n \t\tthrow new Error('matrix is singular');\r\n \t}\r\n \tvar n = $u.ncols(x),\r\n \tlumat = $u.lu(x),\r\n    out = lumat.S;\r\n \tfor (var i = 0;i < n;i++) {\r\n \t\tout = out * lumat.LU[i][i];\r\n \t}\r\n \treturn out;\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/linalgebra/inv.js":"/**\r\n * Linear Equations\r\n */\r\n module.exports = function($u) {\r\n  /**\r\n  * @method inv\r\n  * @summary Matrix inverse\r\n  * @description Inverse of a square matrix\r\n  * \r\n  * @param  {number|array|matrix} x number or array of values\r\n  * @return {number|array|matrix}   \r\n  *\r\n  * @example\r\n  * ubique.inv([[3, 2], [5, 2]]);\r\n  * // [ [ -0.5, 0.5 ], [ 1.25, -0.75 ] ]\r\n  * \r\n  * ubique.inv([[1,1,-1],[1,-2,3],[2,3,1]]);\r\n  * // [ [ 0.846154, 0.307692, -0.076923 ], [ -0.384615, -0.230769, 0.307692 ], [ -0.538462, 0.076923, 0.230769 ] ]\r\n  */\r\n  $u.inv = function(x) {\r\n    if (arguments.length === 0) {\r\n      throw new Error('not enough input arguments');\r\n    }\r\n    if (!$u.issquare(x)) {\r\n      throw new Error('matrix must be square');\r\n    }\r\n    if ($u.isnumber(x)) {\r\n      return 1/x;\r\n    }\r\n    var m = $u.nrows(x);\r\n    var I = $u.eye(m);\r\n    return $u.linsolve(x,I);\r\n\r\n  }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/linalgebra/linsolve.js":"/**\r\n * Linear Equations\r\n */\r\n module.exports = function($u) {\r\n  /**\r\n  * @method linsolve\r\n  * @summary Solve linear system of equations Ax = b\r\n  * @description Solve linear system of equations Ax = b using LU factorization with \r\n  * rows pivoting\r\n  * \r\n  * @param  {matrix} A square matrix\r\n  * @param  {array|matrix} b vector or matrix\r\n  * @return {array|matrix}   \r\n  *\r\n  * @example\r\n  * var transp = ubique.transpose;\r\n  *\r\n  * ubique.linsolve([[1,1,-1],[1,-2,3],[2,3,1]],transp([5,6,3]));\r\n  * [ 5.846154, -2.384615, -1.538462 ]\r\n  * \r\n  * ubique.linsolve([[1,1,-1],[1,-2,3],[2,3,1]],[[4],[-6],[7]]);\r\n  * // [1, 2, -1]\r\n  * \r\n  * ubique.linsolve([[1,1,-1],[1,-2,3],[2,3,1]],ubique.eye(3));\r\n  * // [[0.846154, 0.307692, -0.0769231], [-0.384615, -0.230769, 0.307692], [-0.538462, 0.0769231, 0.230769]]\r\n  */\r\n  $u.linsolve = function(A,b) {\r\n    if (arguments.length <= 1) {\r\n      throw new Error('not enough input arguments');\r\n    }\r\n    if ($u.nrows(A) !== $u.nrows(b)) {\r\n    \tthrow new Error('matrix dimensions must agree');\r\n    }\r\n    if (!$u.issquare(A)) {\r\n      throw new Error('matrix must be square');\r\n    }\r\n    if ($u.isnumber(A) && $u.isnumber(b)) {\r\n      return b/A;\r\n    }\r\n    var lud = $u.lu(A);\r\n    if ($u.issingular(lud.LU)) {\r\n    \tthrow new Error('matrix is singular');\r\n    }\r\n    var LU = lud.LU;\r\n    var m = $u.nrows(LU);\r\n    var bn = $u.ncols(b);\r\n    var bidx = $u.colon(0,bn - 1);\r\n\r\n    if ($u.isarray(b)) {\r\n      x = $u.subset(b,lud.P);\r\n    } else\r\n    if ($u.ismatrix(b)) {\r\n      x = $u.subset(b,lud.P,bidx);\r\n    }\r\n    \r\n    var solve = function(LU,m,x) {\r\n      sum = 0;\r\n      // Solve Ly = b using forward substitution\r\n      for (var i = 1;i < m;i++) {\r\n        sum = x[i];\r\n        for (var j = 0;j < i;j++){\r\n          sum -= LU[i][j] * x[j];\r\n        }\r\n        x[i] = sum;\r\n      }\r\n\r\n      // Solve Ux = y using back substitution\r\n      x[m-1] /= LU[m-1][m-1];\r\n      for (var i = m-2;i >= 0;i--) {\r\n        sum = x[i];\r\n        for (var j = i+1;j < m;j++) {\r\n          sum -= LU[i][j] * x[j];\r\n        }\r\n        x[i] = sum / LU[i][i];\r\n      }\r\n      return x;\r\n    }\r\n    \r\n    for (var h = 0;h < bn;h++) {\r\n      var tcol = $u.getcol(x,h);\r\n      if (h === 0) {\r\n        out = $u.transpose(solve(LU,m,tcol));\r\n      } else {\r\n        out = $u.cat(1,out,$u.transpose(solve(LU,m,tcol)));\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/linalgebra/lu.js":"/**\r\n * Matrix Decomposition\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method lu\r\n * @summary LU matrix factorization\r\n * @description LU matrix factorization based on Doolittle algorithm. The LU decomposition with pivoting always exists, even if the matrix is singular.  \r\n * Returns an object:  \r\n * \r\n * LU (lu matrix) \r\n * L (lower triangular matrix)\r\n * U (upper triangular matrix)\r\n * P (pivot vector)\r\n * S (pivot sign) +1 or -1\r\n * \r\n * @param  {matrix} x input matrix\r\n * @return {object}    .LU (lu matrix) \r\n *                     .L (lower triangular matrix)\r\n *                     .U (upper triangular matrix)\r\n *                     .P (pivot vector)\r\n *                     .S (pivot sign) +1 or -1\r\n *\r\n * @example\r\n * ubique.lu([[5,6,5],[7,8,-1]]);\r\n * // { LU: [ [ 7, 8, -1 ], [ 0.714286, 0.285714, 5.714286 ] ],\r\n * //    L: [ [ 1, 0 ], [ 0.714286, 1 ] ],\r\n * //    U: [ [ 7, 8, -1 ], [ 0, 0.285714, 5.714286 ] ],\r\n * //    P: [ 1, 0 ],\r\n * //    S: -1;}\r\n *\r\n * ubique.lu([[0, 5], [6, 0]]);\r\n * // { LU: [ [ 6, 0 ], [ 0, 5 ] ],\r\n * //    L: [ [ 1, 0 ], [ 0, 1 ] ],\r\n * //    U: [ [ 6, 0 ], [ 0, 5 ] ],\r\n * //    P: [ 1, 0 ],\r\n * //    S: -1;}\r\n */\r\n $u.lu = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n\r\n \t// LU decomposition\r\n \tvar lud = function(a) {\r\n \t\tvar _a = $u.clone(a);\r\n \t\tvar m = $u.nrows(_a);\r\n \t\tvar n = $u.ncols(_a);\r\n \t\tvar piv = $u.colon(0,m - 1);\r\n \t\tvar pivsign = 1;\r\n \t\tvar _arow = [];\r\n \t\tvar _acol = [];\r\n\r\n \t\tfor (var j = 0; j < n; j++) {\r\n\r\n \t\t\t_acol = $u.getcol(_a,j);\r\n\r\n \t\t\tfor (var i = 0; i < m; i++) {\r\n\r\n \t\t\t\t_arow = $u.getrow(_a,i);\r\n\r\n \t\t\t\tvar kmax = Math.min(i, j);\r\n \t\t\t\tvar s = 0;\r\n \t\t\t\tfor (var k = 0; k < kmax; k++) {\r\n \t\t\t\t\ts += _arow[k] * _acol[k];\r\n \t\t\t\t}\r\n \t\t\t\t_arow[j] = _acol[i] -= s;\r\n \t\t\t}\r\n\r\n \t\t\tvar p = j;\r\n \t\t\tfor (var i = j + 1; i < m; i++) {\r\n \t\t\t\tif (Math.abs(_acol[i]) > Math.abs(_acol[p])) {\r\n \t\t\t\t\tp = i;\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t\tif (p !== j) {\r\n \t\t\t\tfor (var k = 0; k < n; k++) {\r\n \t\t\t\t\tvar t = _a[p][k];\r\n \t\t\t\t\t_a[p][k] = _a[j][k];\r\n \t\t\t\t\t_a[j][k] = t;\r\n \t\t\t\t}\r\n \t\t\t\tvar k = piv[p];\r\n \t\t\t\tpiv[p] = piv[j];\r\n \t\t\t\tpiv[j] = k;\r\n \t\t\t\tpivsign = -pivsign;\r\n \t\t\t}\r\n\r\n \t\t\tif (j < m && _a[j][j] !== 0) {\r\n \t\t\t\tfor (var i = j + 1; i < m; i++) {\r\n \t\t\t\t\t_a[i][j] /= _a[j][j];\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\treturn {'Y':_a,'P':piv,'S':pivsign};\r\n \t}\r\n\r\n \t// Lower triangular matrix L\r\n \tvar ltm = function(L) {\r\n \t\tvar m = $u.nrows(L),\r\n \t\tn = $u.ncols(L);\r\n \t\tif (m < n) {\r\n \t\t\tvar _L = $u.zeros(m,m);\r\n \t\t} else {\r\n \t\t\tvar _L = $u.zeros(m,n);\r\n \t\t}\r\n \t\tfor (var i = 0; i < $u.nrows(_L); i++) {\r\n \t\t\tfor (var j = 0; j < $u.ncols(_L); j++) {\r\n \t\t\t\tif (i > j) {\r\n \t\t\t\t\t_L[i][j] = L[i][j];\r\n \t\t\t\t} else \r\n \t\t\t\tif (i == j) {\r\n \t\t\t\t\t_L[i][j] = 1;\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\treturn _L;\r\n \t}\r\n\r\n    // Upper triangular matrix U\r\n    var utm = function(U) {\r\n    \tvar m = $u.nrows(U),\r\n    \tn = $u.ncols(U);\r\n    \tif (m < n) {\r\n    \t\tvar _U = $u.zeros(m,n);\r\n    \t} else {\r\n    \t\tvar _U = $u.zeros(n,n);\r\n    \t}\r\n    \tfor (var i = 0; i < m; i++) {\r\n    \t\tfor (var j = 0; j < n; j++) {\r\n    \t\t\tif (i <= j) {\r\n    \t\t\t\t_U[i][j] = U[i][j];\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \treturn _U;\r\n    }\r\n\r\n    // LU matrix\r\n    var _LU = lud(x);\r\n    return {'LU':_LU.Y,'L':ltm(_LU.Y),'U':utm(_LU.Y),'P':_LU.P,'S':_LU.S};\r\n}\r\n\r\n\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/array.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method array\r\n * @summary Create an array with custom elements\r\n * @description Create an array with custom elements\r\n * \r\n * @param  {number} n number of elements\r\n * @param  {number|string|boolean} val values of the array \r\n * @return {array}       \r\n *\r\n * @example\r\n * ubique.array(3);\r\n * // [ null, null, null ]\r\n * \r\n * ubique.array(3,-1);\r\n * // [-1, -1, -1]\r\n * \r\n * ubique.array(3,'y');\r\n * // [ 'y', 'y', 'y' ]\r\n * \r\n * ubique.array(4,true);\r\n * // [ true, true, true, true ]\r\n */\r\n $u.array = function(n,val) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if (!$u.isnumber(n)) {\r\n    throw new Error('number of elements must be a positive integer');\r\n  }\r\n  val = val == null ? null : val;\r\n  var arr = [];\r\n  for (var i = 0; i < n; i++) {\r\n    arr[i] = val;\r\n  }\r\n  return arr;\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/cat.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method cat\r\n * @summary Concatenate arrays and matrices\r\n * @description Concatenate arrays and matrices along specified dimension as first argument.\r\n * Number size 1x1, Array size 1xN, Matrix size MxN\r\n *              \r\n * @param  {number|array|matrix...} args variable arguments (0:rows, 1:columns)\r\n * @return {array|matrix}     \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * var b = [[-1,3,-1],[4,5,9]];\r\n * var c = [5,6,3];\r\n * var d = [0.5,-3,2.3];\r\n * var f = [[3, 2], [5, 2]];\r\n *\r\n * // Vertical Concatenation (DIM = 0)\r\n * \r\n * ubique.cat(0,1,2,3,4);\r\n * // [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ]\r\n *\r\n * ubique.cat(0,1,2,[3],4);\r\n * // [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ]\r\n *\r\n * ubique.cat(0,1,2,[[3],[4]]);\r\n * // [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ]\r\n *\r\n * ubique.cat(0,[1],2,3,[4]);\r\n * // [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ]\r\n *\r\n * ubique.cat(0,c,d);\r\n * // [ [ 5, 6, 3 ], [ 0.5, -3, 2.3 ] ]\r\n *\r\n * ubique.cat(0,c,d,a);\r\n * // [ [ 5, 6, 3 ], [ 0.5, -3, 2.3 ], [ 5, 6, 5 ], [ 7, 8, -1 ] ]\r\n *\r\n * ubique.cat(0,[[1]],[2],3,4);\r\n * // [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ]\r\n *\r\n * ubique.cat(0,a,c);\r\n * // [ [ 5, 6, 5 ], [ 7, 8, -1 ], [ 5, 6, 3 ] ]\r\n *\r\n * // Horizontal Concatenation (DIM = 1)\r\n *\r\n * ubique.cat(1,1,2,3,4);\r\n * // [ [ 1, 2, 3, 4 ] ]\r\n *\r\n * ubique.cat(1,1,2,[3],4);\r\n * // [ [ 1, 2, 3, 4 ] ]\r\n *\r\n * ubique.cat(1,1,2,[3,4]);\r\n * // [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ]\r\n *\r\n * ubique.cat(1,[1],2,3,4);\r\n * // [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ]\r\n * \r\n * ubique.cat(1,[[1]],2,3,4);\r\n * // [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ]\r\n * \r\n * ubique.cat(1,c,5);\r\n * // [ [ 5, 6, 3, 5 ] ]\r\n * \r\n * ubique.cat(1,c,d);\r\n * // [ [ 5, 6, 3, 0.5, -3, 2.3 ] ]\r\n * \r\n * ubique.cat(1,[[2,3,4,5]],c,d);\r\n * // [ [ 2, 3, 4, 5, 5, 6, 3, 0.5, -3, 2.3 ] ]\r\n */\r\n $u.cat = function() {\r\n \tvar _args = arguments;\r\n \tvar nargs = arguments.length;\r\n  var out = [];\r\n  if (nargs < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var dim = _args[0];\r\n  if (dim !== 0 && dim !== 1) {\r\n    throw new Error('dimension must be 0 (rows) or 1 (columns)');\r\n  }\r\n\r\n  if (dim === 0) {\r\n    for (var i = 1;i < nargs - 1;i++) {\r\n     var tmp = _args[i + 1];\r\n     if ($u.isnumber(_args[1])) {  // number\r\n      if (i === 1) {\r\n        out = [[_args[1]]];\r\n      }\r\n      if ($u.isnumber(tmp)) {\r\n        out.push([tmp]);\r\n      } else\r\n      if ($u.isarray(tmp) && $u.ncols(tmp) === 1) {\r\n        out.push(tmp);\r\n      } else\r\n      if ($u.ismatrix(tmp) && $u.ncols(tmp) === 1) {\r\n        out = out.concat(tmp);\r\n      } else {\r\n        throw new Error('concatenation dimension mismatch');\r\n      }\r\n    } else \r\n    if ($u.isarray(_args[1])) { // array\r\n      if (i === 1) {\r\n        out = [_args[1]]; \r\n      }\r\n      if ($u.isnumber(tmp) && $u.ncols(out) === 1) {\r\n        out.push([tmp]);\r\n      } else\r\n      if ($u.isarray(tmp) && $u.ncols(tmp) === $u.ncols(out)) {\r\n        out.push(tmp);\r\n      } else\r\n      if ($u.ismatrix(tmp) && $u.ncols(tmp) === $u.ncols(out)) {\r\n        out = out.concat(tmp);\r\n      } else {\r\n        throw new Error('concatenation dimension mismatch');\r\n      }\r\n    } else \r\n    if ($u.ismatrix(_args[1])) { // matrix\r\n      if (i === 1) {\r\n        out = _args[1]; \r\n      }\r\n      if ($u.isnumber(tmp) && $u.ncols(out) === 1) {\r\n        out.push([tmp]);\r\n      } else\r\n      if ($u.isarray(tmp) && $u.ncols(tmp) === $u.ncols(out)) {\r\n        out.push(tmp);\r\n      } else\r\n      if ($u.ismatrix(tmp) && $u.ncols(tmp) === $u.ncols(out)) {\r\n        out = out.concat(tmp);\r\n      } else {\r\n        throw new Error('concatenation dimension mismatch');\r\n      }\r\n    } else {\r\n      throw new Error('unknown input arguments');\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\nif (dim === 1) {\r\n  var out = [];\r\n  for (var i = 0;i < nargs - 1;i++) {\r\n    var tmp = _args[i + 1];\r\n    if ($u.isnumber(tmp)) {\r\n      tmp = [[tmp]];\r\n    }\r\n    if ($u.isarray(tmp)) {\r\n      tmp = [tmp];\r\n    }\r\n    if (i === 0) {\r\n      out = $u.clone(tmp);\r\n    } else {\r\n      for (var j = 0;j < $u.nrows(out);j++) {\r\n        var row = out[j];\r\n        row = row.concat(tmp[j]);\r\n        out[j] = row;\r\n      }\r\n    }\r\n  }\r\n  return out;\r\n}\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/clone.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method clone\r\n * @summary Create a clone of the input array or matrix\r\n * @description Create a clone of the input array or matrix\r\n * \r\n * @param  {array|matrix} x array or matrix\r\n * @return {array|matrix}       \r\n *\r\n * @example\r\n * ubique.clone([[-1,3,-1],[4,5,9]]);\r\n * // [ [ -1, 3, -1 ], [ 4, 5, 9 ] ]\r\n * \r\n * ubique.clone([5,6,3]);\r\n * // [ 5, 6, 3 ]\r\n */\r\n $u.clone = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn x;\r\n \t}\r\n \tif ($u.isarray(x)) {\r\n \t\tvar out = new Array(x.length);\r\n \t\tfor (var i = 0; i < x.length; i++) {\r\n \t\t\tout[i] = x[i];\r\n \t\t}\r\n \t\treturn out;\r\n \t}\r\n \tif ($u.ismatrix(x)) {\r\n \t\tvar size = $u.size(x),\r\n \t\tout = new Array(size[0]);\r\n \t\tfor (var i = 0;i < size[0];i++) {\r\n \t\t\tout[i] = new Array(size[1]);\r\n \t\t\tfor (j = 0; j < size[1]; j++) {\r\n \t\t\t\tout[i][j] = x[i][j];\r\n \t\t\t}\r\n \t\t}\r\n \t\treturn out;\r\n \t}\r\n\r\n }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/colon.js":"/**\r\n * Indexing\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method colon\r\n * @summary Array of numbers from L to U with step S\r\n * @description Array of numbers from L to U with step S\r\n * \r\n * @param  {number} l lower value of the array\r\n * @param  {number} u upper value of the array\r\n * @param  {number} s step value (def: 1)\r\n * @return {array}\r\n *\r\n * @example\r\n * ubique.colon(1,10,1);\r\n * // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n * \r\n * ubique.colon(10,1,1);\r\n * //  []\r\n * \r\n * ubique.colon(-5,5,2);\r\n * // [-5, -3, -1, 1, 3, 5]\r\n * \r\n * ubique.colon(-7,14,2);\r\n * // [-7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13]\r\n */\r\n $u.colon = function(l,u,s) {\r\n \tif (arguments.length < 2) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \ts = s == null ? 1 : s;\r\n \tif (s === 0 || (s > 0 && l > u) || (s < 0 && l < u)) {\r\n \t\treturn [];\r\n \t}\r\n \tvar t = $u.fix((u - l) / s);\r\n \tvar out = [];\r\n \tout[0] = l;\r\n \tfor (var i = 1; i <= t; i++ ) {\r\n \t\tout[i] = out[i - 1] + s;\r\n \t}\r\n \treturn out;\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/diag.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n /**\r\n * @method diag\r\n * @summary Diagonal matrix and get diagonals of a matrix\r\n * @description  Diagonal matrix (for array) and get diagonals of a matrix (for matrix)\r\n * \r\n * @param  {array|matrix} x array or matrix values\r\n * @param  {number} k k-th diagonal. 0: main diagonal, k > 0 above, k < 0 below (def: 0)\r\n * @return {array|matrix}   \r\n *\r\n * @example\r\n * // build diag matrix\r\n * ubique.diag([5,6,-3]);\r\n * // [ [ 5, 0, 0 ], [ 0, 6, 0 ], [ 0, 0, -3 ] ]\r\n * \r\n * ubique.diag([5,6,-3],1);\r\n * // [ [ 0, 5, 0, 0 ],[ 0, 0, 6, 0 ],[ 0, 0, 0, -3 ],[ 0, 0, 0, 0 ] ]\r\n * \r\n * ubique.diag([5,6,-3],-1);\r\n * // [ [ 0, 0, 0, 0 ],[ 5, 0, 0, 0 ],[ 0, 6, 0, 0 ],[ 0, 0, -3, 0 ] ]\r\n *\r\n * // get diag values from matrix\r\n * ubique.diag([[5, 0, 0], [0, 6, 0], [0, 0, -3]]);\r\n * // [ 5, 6, -3 ]\r\n * \r\n * ubique.diag([[0, 5, 0, 0], [0, 0, 6, 0], [0, 0, 0, -3], [0, 0, 0, 0]],1);\r\n * // [ 5, 6, -3 ]\r\n * \r\n * ubique.diag([[0, 0, 0, 0], [5, 0, 0, 0], [0, 6, 0, 0], [0, 0, -3, 0]],-1);\r\n * // [ 5, 6, -3 ]\r\n * \r\n * ubique.diag([[5, 0, 0], [0, 6, 0], [0, 0, -3]],2);\r\n * // [0]\r\n */\r\n $u.diag = function(x,k) {\r\n  if (arguments.length < 1) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  k = k == null ? 0 : k;\r\n  var abs = Math.abs;\r\n  if ($u.isarray(x)) {\r\n    var n = x.length;\r\n    var out = $u.zeros(n + abs(k),n + abs(k));\r\n    for (var i = 0;i < n;i++) {\r\n      if (k >= 0) {\r\n       out[i][i + abs(k)] = x[i];\r\n     }\r\n     if (k < 0) {\r\n       out[i + abs(k)][i] = x[i];\r\n     }\r\n   }\r\n   return out;\r\n } else\r\n if ($u.ismatrix(x)) {\r\n  var out = [];\r\n  for (var i = 0;i < $u.nrows(x) - abs(k);i++) {\r\n    if (k >= 0) {\r\n      out.push(x[i][i + abs(k)]);\r\n    }\r\n    if (k < 0) {\r\n      out.push(x[i + abs(k)][i]);\r\n    }\r\n  }\r\n  return out;\r\n} else {\r\n  throw new Error('unknown input');\r\n}\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/end.js":"/**\r\n * Indexing\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method end\r\n * @summary Last index in array or matrix\r\n * @description Last index in array or matrix. Indexing is in the range [0...N-1]\r\n *  \r\n * @param  {array|matrix} x values\r\n * @param  {number} dim\t(only for matrix) -1: [rows,columns], 0: rows, 1: column (def: -1)\r\n * @return {number|array}   \r\n * \r\n * @example\r\n * ubique.end([5,6,3]);\r\n * // 2\r\n * \r\n * ubique.end([[4,5,0],[-1,2,-3]]);\r\n * // [1, 2]\r\n * \r\n * ubique.end([[4,5,0],[-1,2,-3]],0);\r\n * // 1\r\n */\r\n $u.end = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tdim = dim == null ? -1 : dim;\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn x;\r\n \t} else \r\n \tif ($u.isarray(x)) {\r\n \t\treturn x.length - 1;\r\n \t} else\r\n \tif ($u.ismatrix(x)) {\r\n \t\tif (!$u.isinteger(dim) || (dim < -1 || dim > 1)) {\r\n \t\t\tthrow new Error('dimension must be -1,0,1');\r\n \t\t}\r\n \t\tvar idx = [$u.nrows(x) - 1,$u.ncols(x) - 1];\r\n \t\tif (dim === -1) {\r\n \t\t\treturn idx;\r\n \t\t} else {\r\n \t\t\treturn idx[dim];\r\n \t\t}\r\n \t} else \r\n \tthrow new Error('unkown input arguments'); \t\r\n }\r\n\r\n}\r\n\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/eye.js":"/**\r\n* Array Creation and Concatenation\r\n*/\r\nmodule.exports = function($u) {\r\n/**\r\n * @method eye\r\n * @summary Identity matrix\r\n * @description Identity matrix\r\n * \r\n * @param  {number|array|...} args variable input arguments (max 2)\r\n * @return {number|matrix}     \r\n *\r\n * @example\r\n * ubique.eye(0);\r\n * // []\r\n * \r\n * ubique.eye(1);\r\n * // [ [ 1 ] ]\r\n * \r\n * ubique.eye(2);\r\n * // [ [ 1, 0 ], [ 0, 1 ] ]\r\n * \r\n * ubique.eye([2,1]);\r\n * // [ [ 1 ], [ 0 ] ]\r\n * \r\n * ubique.eye(2,3);\r\n * // [ [ 1, 0, 0 ], [ 0, 1, 0 ] ]\r\n */\r\n $u.eye = function() {\r\n  if (arguments.length === 0 ) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _args = $u.argsarray.apply(null,arguments);\r\n  if ($u.ismatrix(_args)) {\r\n    _args = _args[0];\r\n  }\r\n  if (_args.length === 1) {\r\n    _args = [_args[0],_args[0]];\r\n  }\r\n  var matrix =  $u.matrix(_args,0);\r\n  if ($u.isnumber(matrix)) {\r\n    return 1;\r\n  }\r\n  for (var i = 0;i < Math.min.apply(Math,$u.size(matrix));i++) {\r\n   matrix[i][i] = 1;\r\n }\r\n return matrix;\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/falses.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method falses\r\n * @summary Create array of all false\r\n * @description Create array of all false\r\n * \r\n * @param  {number|array|...} args variable input arguments (max 2)\r\n * @return {number|matrix}     \r\n *\r\n * @example\r\n * ubique.falses(0);\r\n * // []\r\n * \r\n * ubique.falses(1);\r\n * // [ [ false ] ]\r\n * \r\n * ubique.falses(2);\r\n * // [ [ false, false ], [ false, false ] ]\r\n * \r\n * ubique.falses([2,1]);\r\n * // [ [ false ], [ false ] ]\r\n * \r\n * ubique.falses(2,3);\r\n * // [ [ false, false, false ], [ false, false, false ] ]\r\n */\r\n $u.falses = function() {\r\n  if (arguments.length === 0 ) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _args = $u.argsarray.apply(null,arguments);\r\n  if ($u.ismatrix(_args)) {\r\n    _args = _args[0];\r\n  }\r\n  if (_args.length === 1) {\r\n    _args = [_args[0],_args[0]];\r\n  }\r\n  return $u.matrix(_args,false);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/find.js":"/**\r\n * Indexing\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method find\r\n * @summary Find indices of nonzero elements\r\n * @description Find indices of nonzero elements\r\n *\r\n * @param  {array|matrix} x values\r\n * @return {array|matrix}   \r\n *\r\n * @example\r\n * ubique.find([0.3,-0.4,0.5,0.9].map(function(a){return a > 0}));\r\n * // [ 0, 2, 3 ]\r\n * \r\n * ubique.find([[true,true],[false,true]]);\r\n * // [ 0, 1, 3 ]\r\n */\r\n $u.find = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    throw Error('input must be an array or matrix');\r\n  }\r\n  if ($u.ismatrix(x)) {\r\n    x = $u.flatten(x); // flatten by rows\r\n  }\r\n  var dummy = $u.colon(0,x.length);\r\n  return dummy.filter(function(el) {\r\n    return x[el] === true;\r\n  })\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/fix.js":"/**\r\n * Arithmetic Operations\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method fix\r\n * @summary Round toward zero\r\n * @description Round toward zero\r\n * \r\n * @param  {number|array|matrix} x number or array of values\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * ubique.fix(3.78);\r\n * // 3\r\n * \r\n * ubique.fix([4.51,-1.4]);\r\n * // [ 4, -1 ]\r\n * \r\n * ubique.fix([[4.51,-1.4],[3.78,0.01]]);\r\n * // [ [ 4, -1 ], [ 3, 0 ] ]\r\n */\r\n $u.fix = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tvar _fix = function(a) {\r\n \t\treturn a < 0 ? Math.ceil(a) : Math.floor(a);\r\n \t}\r\n \treturn $u.arrayfun(x,_fix);\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/flatten.js":"/**\r\n * Sorting and Reshaping Arrays\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method flatten\r\n * @summary Flatten a matrix\r\n * @description Flatten a matrix and returns an array. The concatenation is made by columns (default)\r\n * \r\n * @param  {matrix} x matrix of elements\r\n * @param  {number} dim dimension selected, 1: column 0: row (def: 0)\r\n * @return {array}  \r\n *\r\n * @example\r\n * ubique.flatten([[5,6],[7,8]]);\r\n * // [ 5, 7, 6, 8 ]\r\n *\r\n * // flatten by rows\r\n * ubique.flatten([[1,1,-1],[1,-2,3],[2,3,1]]);\r\n * // [ 1, 1, -1, 1, -2, 3, 2, 3, 1 ]\r\n *\r\n * // flatten by columns\r\n * ubique.flatten([[1,1,-1],[1,-2,3],[2,3,1]],1);\r\n * // [ 1, 1, 2, 1, -2, 3, -1, 3, 1 ]\r\n * \r\n */\r\n $u.flatten = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tdim = dim == null ? 0 : dim;\r\n \tif ($u.isnumber(x) || $u.isarray(x)) {\r\n \t\treturn x;\r\n \t}\r\n \tif ($u.ismatrix(x)) {\r\n \t\tif (dim === 1) {\r\n \t\t\tx = $u.transpose(x);\r\n \t\t}\r\n \t\tx = Array.prototype.concat.apply([], x);\r\n \t\tif (x.some(Array.isArray)) {\r\n \t\t\treturn this.flatten(x);\r\n \t\t} else {\r\n \t\t\treturn x;\r\n \t\t}\r\n \t} else {\r\n \t\tthrow new Error('unknown input arguments');\r\n \t}\r\n }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/flipdim.js":"/**\r\n * Sorting and Reshaping Arrays\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method flipdim\r\n * @summary Flip order of elements in array or matrix\r\n * @description Flip order of elements in array or matrix\r\n * \r\n * @param  {array|matrix} x array or matrix of elements\r\n * @param  {number} dim dimension to apply reverse ordering 0: rows, 1: column (def: 1)\r\n * @return {array|matrix}     \r\n * \r\n * @example\r\n * ubique.flipdim([5,6,3],1);\r\n * // [3, 6, 5]\r\n * \r\n * ubique.flipdim([5,6,3],0);\r\n * // [5, 6, 3]\r\n * \r\n * ubique.flipdim([[5,6,5],[7,8,-1]]);\r\n * // [ [ 5, 6, 5 ], [ -1, 8, 7 ] ]\r\n * \r\n * ubique.flipdim([[5,6,5],[7,8,-1]],0);\r\n * // [ [ 7, 8, -1 ], [ 5, 6, 5 ] ]\r\n */\r\n $u.flipdim = function(x,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim = dim == null ? 1 : dim;\r\n  var _flipdim = function(a) {\r\n    return $u.clone(a.reverse());\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return x;\r\n  } else \r\n  if ($u.isarray(x)) {\r\n    if (dim === 1) {\r\n      return _flipdim(x);\r\n    } else {\r\n      return x;\r\n    }\r\n  } else \r\n  if ($u.ismatrix(x)) {\r\n    return $u.vectorfun(1-dim,x,_flipdim)\r\n  } else {\r\n    throw new Error('unknown input arguments');\r\n  }\r\n\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/fliplr.js":"/**\r\n * Sorting and Reshaping Arrays\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method fliplr\r\n * @summary Flip matrix left to right\r\n * @description Flip matrix left to right\r\n * \r\n * @param  {array|matrix} x array or matrix of lements\r\n * @return {array|matrix}   \r\n *\r\n * @example\r\n * ubique.fliplr([[1,4],[2,5],[3,6]]);\r\n * // [ [ 4, 1 ], [ 5, 2 ], [ 6, 3 ] ]\r\n */\r\n $u.fliplr = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \treturn $u.flipdim(x,1);\r\n }\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/flipud.js":"/**\r\n * Sorting and Reshaping Arrays\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method flipud \r\n * @summary Flip matrix up to down\r\n * @description Flip matrix up to down\r\n * \r\n * @param  {array|matrix} x array or matrix of lements\r\n * @return {array|matrix}   \r\n *\r\n * @example\r\n * ubique.flipud([[1,4],[2,5],[3,6]]);\r\n * // [ [ 3, 6 ], [ 2, 5 ], [ 1, 4 ] ]\r\n */\r\n $u.flipud = function(x) {\r\n  if (arguments.length === 0) {\r\n   throw new Error('not enough input arguments');\r\n }\r\n return $u.flipdim(x,0);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/getcol.js":"/**\r\n * Indexing\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method getcol\r\n * @summary Get a column of a matrix\r\n * @description Get a column of a matrix\r\n * \r\n * @param  {matrix} x matrix of elements\r\n * @param  {number} n column number (indexing from 0 to n - 1)\r\n * @return {array}   \r\n *\r\n * @example\r\n * ubique.getcol([[5,6,5],[7,8,-1]],0);\r\n * // [ 5, 7 ]\r\n * \r\n * ubique.getcol([[5,6,5],[7,8,-1]],2);\r\n * // [ 5, -1 ]\r\n */\r\n $u.getcol = function(x,n) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  n = n == null ? 0 : n;\r\n  if ($u.isarray(x)) {\r\n    throw new Error('input must be a matrix');\r\n  }\r\n  if (!$u.isinteger(n) || n < 0 || n >= $u.ncols(x)) {\r\n    throw new Error('col must be an integer between 0 and N - 1 columns');\r\n  }\r\n  var v = [];\r\n  for (var i = 0;i < x.length;i++) {\r\n    v[i] = x[i][n];\r\n  }\r\n  return v;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/getrow.js":"/**\r\n * Indexing\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method getrow\r\n * @summary Get a row of matrix\r\n * @description  Get a row of a matrix\r\n * \r\n * @param  {matrix} x matrix of elements\r\n * @param  {number} n row number (indexing from 0 to n - 1)\r\n * @return {array}   \r\n *\r\n * @example\r\n * ubique.getrow([[5,6,5],[7,8,-1]],0);\r\n * // [ 5, 6, 5 ]\r\n * \r\n * ubique.getrow([[5,6,5],[7,8,-1]],1);\r\n * // [ 7, 8, -1 ]\r\n */\r\n $u.getrow = function(x,n) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  n = n == null ? 0 : n;\r\n  if ($u.isarray(x)) {\r\n   throw new Error('input must be a matrix');\r\n  }\r\n  if (!$u.isinteger(n) || n < 0 || n >= $u.nrows(x)) {\r\n    throw new Error('row must be an integer between 0 and N - 1 rows');\r\n  }\r\n  return x[n];\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/horzcat.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method horzcat\r\n * @summary Concatenate arrays or matrices horizontally\r\n * @description Concatenate arrays or matrices horizontally\r\n *              \r\n * @param  {array|matrix|...} args variable arguments (args1,args2,...)\r\n * @return {array|matrix}     \r\n *\r\n * @example\r\n * ubique.horzcat([[5,6,5],[7,8,-1]],[[-1,3,-1],[4,5,9]]);\r\n * // [ [ 5, 6, 5, -1, 3, -1 ], [ 7, 8, -1, 4, 5, 9 ] ]\r\n * \r\n * ubique.horzcat(5,6,7);\r\n * // [ [ 5, 6, 7 ] ]\r\n * \r\n */\r\n $u.horzcat = function() {\r\n   var _args = $u.argsarray.apply(null,arguments);\r\n   return $u.cat.apply(null,[].concat(1,_args));\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/ind2sub.js":"/**\r\n * Indexing\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method ind2sub\r\n * @summary Multiple subscripts from linear index\r\n * @description Multiple subscripts from linear index. Returns an array or matrix with \r\n * the equivalent row and column of the corresponding index. \r\n * \r\n * @param  {array|matrix} size size of array or matrix\r\n * @param  {number|array} index linear indexing [0...N-1]\r\n * @return {array|matrix}       \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * \r\n * ubique.ind2sub(ubique.size(a),5);\r\n * // [1, 2]\r\n * \r\n * ubique.ind2sub(ubique.size(a),[0,1,2]);\r\n * // [[0, 0], [1, 0], [0, 1]]\r\n * \r\n * ubique.ind2sub(ubique.size([5,6,3]),2);\r\n * // [2, 0]\r\n */\r\n $u.ind2sub = function(size,index) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _ind2sub = function(siz,idx) {\r\n    var v = $u.rem(idx, siz[0]);\r\n    return [v ,(idx - v) / siz[0]];\r\n  }\r\n  if ($u.isarray(index)) {\r\n    var out = [];\r\n    for (var i = 0;i < index.length;i++) {\r\n      out.push(_ind2sub(size,index[i]));\r\n    }\r\n    return out;\r\n  }\r\n  return _ind2sub(size,index);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/iscolumn.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method iscolumn\r\n * @summary True for column vector\r\n * @description True for column vector\r\n *              \r\n * @param  {matrix} x input matrix\r\n * @return {Boolean}   \r\n *\r\n * @example\r\n * ubique.iscolumn([[2],[2]]);\r\n * // true\r\n */\r\n $u.iscolumn = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.nrows(x) > 1 && $u.ncols(x) === 1) {\r\n \t\treturn true;\r\n \t}\r\n \treturn false;\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/isrow.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method isrow\r\n * @summary True for row vector\r\n * @description True for row vector\r\n *              \r\n * @param  {matrix} x input matrix\r\n * @return {Boolean}   \r\n *\r\n * @example\r\n * ubique.isrow([[2,2]]);\r\n * // true\r\n */\r\n $u.isrow = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.nrows(x) === 1 && $u.ncols(x) > 1) {\r\n \t\treturn true;\r\n \t}\r\n \treturn false;\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/issquare.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method issquare\r\n * @summary True for square matrix\r\n * @description True for square matrix\r\n *              \r\n * @param  {matrix} x input matrix\r\n * @return {Boolean}   \r\n *\r\n * @example\r\n * ubique.issquare([[9, 5], [6, 1]]);\r\n * // true\r\n */\r\n $u.issquare = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.nrows(x) === $u.ncols(x)) {\r\n \t\treturn true;\r\n \t}\r\n \treturn false;\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/length.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n* @method length\r\n* @summary length of vector or largest array dimension\r\n* @description  length of vector or largest array dimension\r\n* \r\n* @param  {array|matrix} x array of elements\r\n* @return {number}\r\n*\r\n* @example\r\n* ubique.length([3,5,6]);\r\n* // 3\r\n* \r\n* ubique.length(5);\r\n* // 1\r\n* \r\n* ubique.length([[5,4],[-1,2]]);\r\n* // 2\r\n*/\r\n$u.length = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return Math.max.apply(null,$u.size(x));\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/linspace.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method linspace\r\n * @summary Create linearly spaced arrays\r\n * @description  Create linearly spaced arrays\r\n *            \r\n * @param  {number} a lower bound\r\n * @param  {number} b upper bound\r\n * @param  {number} n number of points\r\n * @return {array}\r\n *\r\n * @example\r\n * ubique.linspace(1,10,5);\r\n * // [ 1, 3.25, 5.5, 7.75, 10 ]\r\n */\r\n $u.linspace = function(a,b,n) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  n = n == null ? 10 : n;\r\n  var v = [];\r\n  var step = (b - a) / (n - 1);\r\n  v[0] = a;\r\n  v[n - 1] = b;\r\n  for (var i = 0;i < n;i++) {\r\n   v[i] = a + step * i;\r\n }\r\n return v;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/logspace.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method logspace\r\n * @summary Create logarithmically spaced arrays\r\n * @description  Create logarithmically spaced arrays\r\n *            \r\n * @param  {number} a lower bound\r\n * @param  {number} b upper bound\r\n * @param  {number} n number of points\r\n * @return {array}\r\n *\r\n * @example\r\n * ubique.logspace(0,1,5);\r\n * // [ 1, 1.778279, 3.162278, 5.623413, 10 ]\r\n */\r\n $u.logspace = function(a,b,n) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  n = n == null ? 10 : n;\r\n  return $u.linspace(a,b,n).map(function(val){return Math.pow(10,val)});\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/matrix.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method matrix\r\n * @summary Create a matrix object\r\n * @description Create a matrix object with minimum 1 argument, max 3 arguments. The first arg can be a number or array, the last one is the value to\r\n * replicate in the matrix. Default value is NULL. Example: a matrix(2) returns an array of array with dimension 2x2, a matrix(2,3) or matrix([2,3]) a matrix \r\n * with dimension 2x3 and values equal to NULL.\r\n * \r\n * @param  {number|string|boolean|array|...} args variable input arguments (max 3)\r\n * @return {matrix}       \r\n *\r\n * @example\r\n * ubique.matrix(0);\r\n * // [ [] ]\r\n *\r\n * ubique.matrix([0,0]);\r\n * // [ [] ]\r\n * \r\n * ubique.matrix(2);\r\n * // [ [ null, null ], [ null, null ] ]\r\n * \r\n * ubique.matrix([2,3]);\r\n * // [ [ null, null, null ], [ null, null, null ] ]\r\n * \r\n * ubique.matrix(2,3);\r\n * // [ [ null, null, null ], [ null, null, null ] ]\r\n * \r\n * ubique.matrix([2,3],-1);\r\n * // [ [ -1, -1, -1 ], [ -1, -1, -1 ] ]\r\n * \r\n *\r\n * ubique.matrix(3,1,'matrix');\r\n * // [ [ 'matrix' ], [ 'matrix' ], [ 'matrix' ] ]\r\n *\r\n * ubique.matrix(0,5,true);\r\n * // [ [] ]\r\n */\r\n $u.matrix = function() {\r\n \tif (arguments.length === 0 ) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  var args = $u.argsarray.apply(null,arguments);\r\n  var nargs = args.length;\r\n\r\n  var _matrix = function(x,y,val) {\r\n    var mat = [];\r\n    for (var i = 0; i < x; i++) {\r\n      mat[i] = [];\r\n      for (var j = 0; j < y; j++) {\r\n        mat[i][j] = val;\r\n      }\r\n    }\r\n    return mat;\r\n  }\r\n  if ($u.isempty(args)) {\r\n    return [[]];\r\n  }\r\n  if (nargs === 1) {\r\n    if ($u.isnumber(args[0])) {\r\n      if (args[0] === 0) {\r\n        return [[]];\r\n      }\r\n      return _matrix(args[0],args[0],null);\r\n    } else\r\n    if ($u.isarray(args[0])) {\r\n      if (args[0].length === 1) {\r\n        if (args[0][0] === 0) {\r\n          return [[]];\r\n        } else {\r\n          return _matrix(args[0][0],args[0][0],null);\r\n        }\r\n      }\r\n      if (args[0][0] === 0 || args[0][1] === 0) {\r\n        return [[]];\r\n      }\r\n      return _matrix(args[0][0],args[0][1],null);\r\n    } else {\r\n      throw new Error('unknwon input type');\r\n    }\r\n  } else\r\n  if (nargs === 2) {\r\n    if ($u.isnumber(args[0]) && $u.isnumber(args[1])) {\r\n      return _matrix(args[0],args[1],null);\r\n    }\r\n    return _matrix(args[0][0],args[0][1],args[1]);\r\n  } else\r\n  if (nargs === 3) {\r\n    if (args[0] === 0 || args[1] === 0) {\r\n      return [[]];\r\n    }\r\n    return _matrix(args[0],args[1],args[2]);\r\n  } else {\r\n    throw new Error('too manny input arguments');\r\n  }\r\n}\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/mergesort.js":"/**\r\n * Sorting and Reshaping Arrays\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method mergesort\r\n * @summary Sort array in ascending/descending order\r\n * @description  Mergesort is a divide and conquer algorithm that was invented by John von Neumann.\r\n * A merge sort works as follows:\r\n * \r\n * 1 - Divide the unsorted list into n sublists, each containing 1 element (a list of 1 element is considered sorted).\r\n * 2 - Repeatedly merge sublists to produce new sorted sublists until there is only 1 sublist remaining. This will be the sorted list.\r\n * \r\n * Source: [Merge sort](http://en.wikipedia.org/wiki/Merge_sort)\r\n *\r\n * Returns sorted values with sorted indexes as array of array (matrix)\r\n * \r\n * @param  {array} x array of elements\r\n * @param  {string} mode sorting direction, \"ascend\" (default) or \"descend\"\r\n * @return {matrix}   \r\n *\r\n * @example\r\n * // mergesort with input values and indexes\r\n * ubique.mergesort([[9,-3,2,-12,0,1],[0,1,2,3,4,5]]);\r\n * // [ [ -12, -3, 0, 1, 2, 9 ], [ 3, 1, 4, 5, 2, 0 ] ]\r\n *\r\n * // with only an array of input values\r\n * ubique.mergesort([9,-3,2,-12,0,1]);\r\n * // [ [ -12, -3, 0, 1, 2, 9 ], [ 3, 1, 4, 5, 2, 0 ] ]\r\n * \r\n * ubique.mergesort([9,-3,2,-12,0,1],'descend');\r\n * // [ [ 9, 2, 1, 0, -3, -12 ], [ 0, 2, 5, 4, 1, 3 ] ]\r\n */\r\n $u.mergesort = function(x,mode) {\r\n  var self = this;\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if ($u.isarray(x)) {\r\n    x = [x,$u.colon(0,x.length-1)];\r\n  }\r\n  var len = x[0].length;\r\n  mode = mode || 'ascend';\r\n  if (len < 2) {\r\n    return x;\r\n  }\r\n  var cx = parseInt(len / 2);\r\n  var sx = x[0].slice(0, cx);\r\n  var sxi = x[1].slice(0,cx);\r\n  var dx  = x[0].slice(cx, len);\r\n  var dxi = x[1].slice(cx,len);\r\n  var _sx = [sx,sxi];\r\n  var _dx = [dx,dxi];\r\n\r\n  var merge = function(sxarr,dxarr,mode) {\r\n    var sorted = [];\r\n    var idx = [];\r\n    while (sxarr[0].length && dxarr[0].length) {\r\n      if (mode === 'ascend') {\r\n        var compare = sxarr[0][0] <= dxarr[0][0];\r\n      } else \r\n      if (mode === 'descend') {\r\n        var compare = sxarr[0][0] >= dxarr[0][0];\r\n      } else {\r\n        throw new Error('sorting must be \"ascend\" or \"descend\"');\r\n      }\r\n      if (compare) {\r\n        sorted.push(sxarr[0].shift());\r\n        idx.push(sxarr[1].shift());\r\n      } else {\r\n        sorted.push(dxarr[0].shift());\r\n        idx.push(dxarr[1].shift());\r\n      }\r\n    }\r\n    while (sxarr[0].length) {\r\n      sorted.push(sxarr[0].shift());\r\n      idx.push(sxarr[1].shift());\r\n    }\r\n    while (dxarr[0].length) {\r\n      sorted.push(dxarr[0].shift());\r\n      idx.push(dxarr[1].shift());\r\n    }\r\n    return [sorted,idx];\r\n  }\r\n  return merge(self.mergesort(_sx,mode),self.mergesort(_dx,mode),mode);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/ncols.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method ncols\r\n * @summary Number of columns in vector|matrix MxN\r\n * @description Number of columns in vector|matrix. Array ~ Row vector, returns N.\r\n * \r\n * @param  {array|matrix} x array of elements\r\n * @return {number}   \r\n *\r\n * @example\r\n * ubique.ncols([5,6,7]);\r\n * // 3\r\n * \r\n * ubique.ncols([[3,2,7],[4,5,6]]);\r\n * //  3\r\n */\r\n $u.ncols = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return $u.size(x)[1];\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/ndims.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n* @method ndims\r\n* @summary Number of array dimensions\r\n* @description Number of array dimensions\r\n* \r\n* @param  {array|matrix} x array of elements\r\n* @return {number}  \r\n*\r\n* @example\r\n* ubique.ndims([3,5,6]);\r\n* // 2\r\n* \r\n* ubique.ndims([[3,2,7],[4,5,6]]);\r\n* // 2\r\n*/\r\n$u.ndims = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return $u.length($u.size(x));\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/nrows.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method nrows\r\n * @summary Number of rows in vector|matrix MxN\r\n * @description Number of rows in vector|matrix. Array ~ Row vector, returns 1.\r\n * \r\n * @param  {array|matrix} x array of elements\r\n * @return {number}  \r\n *\r\n * @example\r\n * ubique.nrows([5,6,7]);\r\n * // 1\r\n * \r\n * ubique.nrows([[3,2,7],[4,5,6]]);\r\n * // 2\r\n */\r\n $u.nrows = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  return $u.size(x)[0];\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/numel.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n\t/**\r\n * @method numel\r\n * @summary Number of elements in an array\r\n * @description Number of elements in an array\r\n * \r\n * @param  {array|matrix} x array of elements\r\n * @return {number} \r\n *\r\n * @example\r\n * ubique.numel([3,5,6]);\r\n * // 3\r\n * \r\n * ubique.numel([[3,2,7],[4,5,6]]);\r\n * // 6\r\n */\r\n $u.numel = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var size = $u.size(x);\r\n  return size[0] * size[1];\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/ones.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method ones\r\n * @summary Create array of all ones\r\n * @description Create array of all ones\r\n * \r\n * @param  {number|array|...} args variable input arguments (max 2)\r\n * @return {number|matrix}     \r\n *\r\n * @example\r\n * ubique.ones(0);\r\n * // []\r\n * \r\n * ubique.ones(1);\r\n * // [ [ 1 ] ]\r\n * \r\n * ubique.ones(2);\r\n * // [ [ 1, 1 ], [ 1, 1 ] ]\r\n * \r\n * ubique.ones([2,1]);\r\n * // [ [ 1 ], [ 1 ] ]\r\n * \r\n * ubique.ones(2,3);\r\n * // [ [ 1, 1, 1 ], [ 1, 1, 1 ] ]\r\n */\r\n $u.ones = function() {\r\n if (arguments.length === 0 ) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _args = $u.argsarray.apply(null,arguments);\r\n  if ($u.ismatrix(_args)) {\r\n    _args = _args[0];\r\n  }\r\n  if (_args.length === 1) {\r\n    _args = [_args[0],_args[0]];\r\n  }\r\n  return $u.matrix(_args,1);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/rand.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method rand\r\n * @summary Uniformly distribuited pseudorandom numbers\r\n * @description Uniformly distribuited pseudorandom numbers\r\n * \r\n * @param  {number|array|...} args variable input arguments (max 2)\r\n * @return {number|matrix}    \r\n *\r\n * @example\r\n * ubique.rand();\r\n * // 0.1455961789470166\r\n * ubique.rand(0);\r\n * // []\r\n * ubique.rand(1);\r\n * // [[0.12391899712383747]]\r\n * ubique.rand(2);\r\n * // [[0.33334478829056025, 0.09839745867066085],[0.6006140187382698, 0.3131265211850405]]\r\n * ubique.rand([2,1]);\r\n * // [[0.40439655422233045], [0.7663801296148449]]\r\n * ubique.rand(1,2);\r\n * // [[0.16782891773618758, 0.5958379742223769]]\r\n * ubique.rand(2,3);\r\n * // [[0.890318026766181, 0.7398379456717521, 0.6165686929598451], [0.7234933257568628, 0.9895968120545149, 0.875643968814984]]\r\n */\r\n $u.rand = function() {\r\n \tvar _args = arguments,\r\n \tnargs = arguments.length;\r\n \tvar _rand = function(x,y) {\r\n \t\tvar out = new Array(x);\r\n \t\tfor (var i = 0;i < x;i++) {\r\n \t\t\tout[i] = new Array(y);\r\n \t\t\tfor (j = 0; j < y; j++) {\r\n \t\t\t\tout[i][j] = Math.random();\r\n \t\t\t}\r\n \t\t}\r\n \t\treturn out;\r\n \t}\r\n \tif (nargs === 0) {\r\n \t\treturn Math.random();\r\n \t} else\r\n \tif (nargs === 1) {\r\n \t\tif ($u.isnumber(_args[0])) {\r\n \t\t\treturn _rand(_args[0],_args[0]);\r\n \t\t} else \r\n \t\tif ($u.isarray(_args[0])) {\r\n \t\t\treturn _rand(_args[0][0],_args[0][1]);\r\n \t\t} else {\r\n \t\t\tthrow new Error('unknwon input type');\r\n \t\t}\r\n \t} else\r\n \tif (nargs === 2) {\r\n \t\tif ($u.isnumber(_args[0]) && $u.isnumber(_args[1])) {\r\n \t\t\treturn _rand(_args[0],_args[1]);\r\n \t\t}\r\n \t\treturn _rand(_args[0][0],_args[0][1],_args[1]);\r\n \t} else\r\n \tif (nargs === 3) {\r\n \t\treturn _rand(_args[0],_args[1],_args[2]);\r\n \t} else\r\n \tthrow new Error('too manny input arguments');\r\n }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/repmat.js":"/**\r\n * Sorting and Reshaping Arrays\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method  repmat\r\n * @summary Replicate and tile array\r\n * @description  Replicate and tile array\r\n *\r\n * @param  {number|array|matrix|boolean} x value assigned to every elements of array or matrix\r\n * @param  {number} m number of matrix rows\r\n * @param  {number} n number of matrix columns\r\n * @return {matrix}     \r\n *\r\n * @example\r\n * var l = [[1,1,-1],[1,-2,3],[2,3,1]];\r\n * \r\n * ubique.repmat(10,3);\r\n * // [ [ 10, 10, 10 ], [ 10, 10, 10 ], [ 10, 10, 10 ] ]\r\n * \r\n * ubique.repmat(0.5,3,2);\r\n * // [ [ 0.5, 0.5 ], [ 0.5, 0.5 ], [ 0.5, 0.5 ] ]\r\n * \r\n * ubique.repmat([5,6,3],1,2);\r\n * // [ [ 5, 6, 3, 5, 6, 3 ] ]\r\n * \r\n * ubique.repmat([[9, 5],[6, 1]],2);\r\n * // [ [ 9, 5, 9, 5 ], [ 6, 1, 6, 1 ], [ 9, 5, 9, 5 ], [ 6, 1, 6, 1 ] ]\r\n */\r\n $u.repmat = function(x,m,n) {\r\n \tif (arguments.length < 2) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif (arguments.length === 2) {\r\n \t\tn = m;\r\n \t}\r\n \tif ($u.isnumber(x) || $u.isarray(x) || $u.islogical(x)) {\r\n \t\tx = $u.tomat(x);\r\n \t}\r\n \tvar size = $u.size(x);\r\n \tvar out = $u.matrix(size[0]*m,size[1]*n);\r\n \tfor (var i = 0; i < m; i++) {\r\n \t\tfor (var j = 0; j < n; j++) {\r\n \t\t\tfor (var ii = 0; ii < size[0]; ii++) {\r\n \t\t\t\tfor (var jj = 0; jj < size[1]; jj++) {\r\n \t\t\t\t\tout[(i * size[0]) + ii][(j * size[1]) + jj] = x[ii][jj];\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t}\r\n \treturn out;\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/reshape.js":"/**\r\n * Sorting and Reshaping Arrays\r\n */\r\n module.exports = function($u) {\r\n /**\r\n * @method  reshape\r\n * @summary Reshape array or matrix with custom values\r\n * @description  Reshape array or matrix with custom values based on rows values of X\r\n *\r\n * @param  {array|matrix} x array or matrix of elements\r\n * @param  {number} m number of rows for the new matrix\r\n * @param  {number} n number of cols for the new matrix\r\n * @param  {number} flag flag 0: rowwise element, 1: columnwise (def: 0)\r\n * @return {matrix}     \r\n *\r\n * @example \r\n * ubique.reshape([5,6,3],3,1);\r\n * // [ [ 5 ], [ 6 ], [ 3 ] ]\r\n *\r\n * ubique.reshape([5,6,3],1,3);\r\n * // [ 5, 6, 3 ]\r\n * \r\n * ubique.reshape([[-1,3,-1],[4,5,9]],3,2);\r\n * // [ [ -1, 4 ], [ 3, 5 ], [ -1, 9 ] ]\r\n *\r\n * ubique.reshape([[-1,3,-1],[4,5,9]],3,2,1);\r\n * // [ [ -1, 5 ], [ 4, -1 ], [ 3, 9 ] ]\r\n * \r\n * ubique.reshape([[-1,3,-1],[4,5,9]],6,1);\r\n * // [ [ -1 ], [ 3 ], [ -1 ], [ 4 ], [ 5 ], [ 9 ] ]\r\n *\r\n * ubique.reshape([[-1,3,-1],[4,5,9]],6,1,1);\r\n * // [ [ -1 ], [ 4 ], [ 3 ], [ 5 ], [ -1 ], [ 9 ] ]\r\n */\r\n $u.reshape = function(x,m,n,flag) {\r\n \tif (arguments.length < 3) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  flag = flag == null ? 0 : flag;\r\n \tif (!$u.isinteger(m) || !$u.isinteger(n)) {\r\n \t\tthrow new Error('dimensions must be integer numbers');\r\n \t}\r\n \tvar nrows = $u.nrows(x);\r\n \tvar ncols = $u.ncols(x);\r\n \tvar totsiz = nrows * ncols;\r\n \tif ((m * n) !== totsiz ) {\r\n \t\tthrow new Error('total number of elements must be the same');\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn x;\r\n \t} else \r\n \tif ($u.isarray(x)) {\r\n \t\tif (m === nrows && n === ncols) {\r\n \t\t\treturn x;\r\n \t\t} else {\r\n \t\t\treturn $u.transpose(x);\r\n \t\t}\r\n \t} else \r\n \tif ($u.ismatrix(x)) {\r\n \t\tvar out = $u.matrix(m,n,NaN);\r\n \t\tvar vec = $u.flatten(x,flag); // flatten by rows\r\n \t\tfor (var i = 0;i < m * n;i++) {\r\n \t\t\tvar idx = $u.ind2sub([m,n],i);\r\n \t\t\tout[idx[0]][idx[1]] = vec[i];\r\n \t\t}\r\n \t\treturn out;\r\n \t} else {\r\n \t\tthrow new Error('unknown input arguments');\r\n \t}\r\n\r\n }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/setcol.js":"/**\r\n * Indexing\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method setcol\r\n * @summary Set a column of a matrix\r\n * @description Set a column of a matrix. If X is an array, it is auto-converted to\r\n * a column vector.\r\n * \r\n * @param  {array|vector} x array or vector Mx1\r\n * @param  {matrix} mat matrix MxN of values\r\n * @param  {number} n column number (indexing from 0 to n - 1)\r\n * @return {matrix}   \r\n *\r\n * @example\r\n * ubique.setcol([2,0],[[5,6,5],[7,8,-1]],0);\r\n * // [ [ 2, 6, 5 ], [ 0, 8, -1 ] ]\r\n *\r\n * ubique.setcol([9,21],[[5,6,5],[7,8,-1]],2);\r\n * // [ [ 5, 6, 9 ], [ 7, 8, 21 ] ]\r\n */\r\n $u.setcol = function(x,mat,n) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  n = n == null ? 0 : n;\r\n  if ($u.isarray(x)) {\r\n    x = $u.transpose(x);\r\n  }\r\n  if (!$u.isinteger(n) || n < 0 || n >= $u.ncols(mat)) {\r\n    throw new Error('col must be an integer between 0 and N - 1 columns');\r\n  }\r\n  for (var i = 0;i < $u.nrows(mat);i++) {\r\n    mat[i][n] = x[i][0];\r\n  }\r\n  return mat;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/setrow.js":"/**\r\n * Indexing\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method setrow\r\n * @summary Set a row of matrix\r\n * @description Set a row of a matrix.If X is an array, it is auto-converted to\r\n * a row vector.\r\n * \r\n * @param  {array|vector} x array or vector 1xN\r\n * @param  {matrix} mat matrix MxN of values\r\n * @param  {number} n column number (indexing from 0 to n - 1)\r\n * @return {matrix}   \r\n *\r\n * @example\r\n * ubique.setrow([2,0,-2],[[5,6,5],[7,8,-1]],0);\r\n * // [ [ 2, 0, -2 ], [ 7, 8, -1 ] ]\r\n *\r\n * ubique.setrow([9,21,57],[[5,6,5],[7,8,-1]],1);\r\n * // [ [ 5, 6, 5 ], [ 9, 21, 57 ] ]\r\n */\r\n $u.setrow = function(x,mat,n) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  n = n == null ? 0 : n;\r\n  if ($u.isarray(x)) {\r\n   x = [x];\r\n  }\r\n  if (!$u.isinteger(n) || n < 0 || n >= $u.nrows(mat)) {\r\n    throw new Error('row must be an integer between 0 and N - 1 rows');\r\n  }\r\n  for (var i = 0;i < $u.ncols(mat);i++) {\r\n    mat[n][i] = x[0][i];\r\n  }\r\n  return mat;\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/size.js":"/**\r\n * Array Dimensions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method size\r\n * @summary Size of N-D array\r\n * @description Size of N-D array. N-D array is equal to MxN matrix, \r\n * 1-D Array is equal to 1xN, Number is equal to 1x1 array\r\n * \r\n * @param  {string|number|array|matrix} x array of elements\r\n * @return {array}  \r\n *\r\n * @example\r\n * ubique.size([[[[5,6,5],[7,8,-1]]]]);\r\n * // [ 1, 1, 2, 3 ]\r\n * \r\n * ubique.size([[3,2,7],[4,5,6]]);\r\n * //  [ 2, 3 ]\r\n * \r\n * ubique.size([5,4,4]);\r\n * // [ 1, 3 ]\r\n * \r\n * ubique.size(5);\r\n * // [ 1, 1 ]\r\n * \r\n * ubique.size('ubique');\r\n * // [ 1, 6 ]\r\n * \r\n * ubique.size([['first','second']]);\r\n * // [ 1, 2 ]\r\n */\r\n $u.size = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isnull(x) || $u.isundefined(x)) {\r\n \t\tthrow new Error('unknown input type');\r\n \t}\r\n  if ($u.isstring(x)) {\r\n    return [1,x.length];\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return [1, 1];\r\n  }\r\n  if ($u.isarray(x)) {\r\n    return [1,x.length];\r\n  }\r\n  var siz = x.length;\r\n  var _siz = [];\r\n  while (!$u.isundefined(siz) && !$u.isstring(x)) {\r\n   _siz.push(siz);\r\n   x = x[0];\r\n   siz = x.length;\r\n } \r\n return _siz;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/sort.js":"/**\r\n * Sorting and Reshaping Arrays\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method sort\r\n * @summary Sort array elements in ascending/descending order\r\n * @description Sort array elements in ascending/descending order. For matrix it is possibile to sort\r\n * along a dimension. Based on Merge Sort algorithm\r\n * \r\n * @param   {array|matrix} x array of elements\r\n * @param   {string} mode sorting direction, 'ascend' (default) or 'descend'\r\n * @param   {number} dim dimension along which to sort, 0: rows, 1: colums (def: 1)\r\n * @return  {array}      \r\n *\r\n * @example\r\n * ubique.sort([0,5,-1,3,-4,9,0],'ascend');\r\n * // [ -4, -1, 0, 0, 3, 5, 9 ]\r\n *\r\n * ubique.sort([[-1,3,-1],[4,5,9]],'descend');\r\n * // [ [ 4, 5, 9 ], [ -1, 3, -1 ] ]\r\n * \r\n * ubique.sort([[-1,3,-1],[4,5,9]],'descend',0);\r\n * // [ [ 3, -1, -1 ], [ 9, 5, 4 ] ]\r\n */\r\n $u.sort = function(x,mode,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  mode = mode == null ? 'ascend' : mode;\r\n  dim = dim == null ? 1 : dim;\r\n  var _sort = function(a,mode) {\r\n    var out = $u.mergesort(a,mode);\r\n    return out[0];\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return x;\r\n  }\r\n  if ($u.isarray(x)) {\r\n   return _sort(x,mode);\r\n }\r\n return $u.vectorfun(dim,x,_sort,mode);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/squeeze.js":"/**\r\n * Sorting and Reshaping Arrays\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method squeeze\r\n * @summary Remove singleton dimensions from N-D arrays (matrices)\r\n * @description Remove singleton dimensions N_D arrays (matrices).\r\n * Number returns number and 1-D array returns 1-D array.\r\n * \r\n * @param  {string|number|array|matrix} x elements of X\r\n * @return {string|number|array|matrix}   \r\n *\r\n * @example\r\n * ubique.squeeze([[[[[8]]]]]);\r\n * // [ [ 8 ] ]\r\n * \r\n * ubique.squeeze([[[[3,4,5]]]]); \r\n * // [ [3, 4, 5] ]\r\n * \r\n * ubique.squeeze([[[[[['31-12-2014','31-01-2015'],['15-02-2015','01-03-2015']]]]]]);\r\n * // [ [ '31-12-2014', '31-01-2015' ],[ '15-02-2015', '01-03-2015' ] ]\r\n */\r\n $u.squeeze = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif (arguments.length > 1) {\r\n \t\tthrow new Error('too many input arguments');\r\n \t}\r\n \tif ($u.isnumber(x) || $u.isstring(x)) {\r\n \t\treturn x;\r\n \t}\r\n \tvar size = $u.size(x);\r\n \twhile (size.length > 2) {\r\n \t\tx = x[0];\r\n \t\tsize = $u.size(x);\r\n \t}\r\n \treturn x;\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/sub2ind.js":"/**\r\n * Indexing\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method sub2ind\r\n * @summary Subscripts to linear indices\r\n * @description Subscripts to linear indices. Convert a 2D coordinates X,Y of a matrix into linear indices\r\n * \r\n * @param  {array|matrix} size  size of array or matrix\r\n * @param  {array|matrix} index X,Y coordinates for 2D matrices in the range [0...N-1]\r\n * @return {number|array}       \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * \r\n * ubique.sub2ind(ubique.size(a),[1, 2]);\r\n * // 5\r\n * \r\n * ubique.sub2ind(ubique.size(a),[[0, 0], [1, 0], [0, 1]]);\r\n * // [0, 1, 2]\r\n * \r\n * ubique.sub2ind(ubique.size([5,6,3]),[2, 0]);\r\n * // 2\r\n */\r\n $u.sub2ind = function(size,index) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isarray(index)) {\r\n \t\tindex = [index];\r\n \t}\r\n \tvar x = $u.getcol(index,0);\r\n \tvar y = $u.getcol(index,1);\r\n \tvar v = [];\r\n \tfor (var i = 0;i < x.length;i++) {\r\n \t\tv[i] = (x[i]) + (y[i]) * size[0];\r\n \t}\r\n \tif ($u.numel(v) === 1) {\r\n \t\treturn $u.squeeze(v)[0];\r\n \t}  else {\r\n \t\treturn $u.squeeze(v);\r\n \t}\r\n }\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/subset.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n /**\r\n  * @method subset\r\n  * @summary Subset of array or matrix based on X,Y coordinates\r\n  * @description Subset of array or matrix based on X,Y coordinates.\r\n  * Extract a single column or row with the symbols ':'\r\n  * \r\n  * @param  {array|matrix} m array or matrix of elements\r\n  * @param  {number|array|string} r indexing for rows or ':' for all rows\r\n  * @param  {number|array|string} c indexing for columns or ':' for all columns\r\n  * @return {number|array|matrix}\r\n  *\r\n  * @example\r\n  * var a = [[5,6,5],[7,8,-1]];\r\n  * var c = [5,6,3];\r\n  *\r\n  * ubique.subset(c,1);\r\n  * // 6\r\n  * \r\n  * ubique.subset(c,[1,2]);\r\n  * // [ 6, 3 ]\r\n  * \r\n  * ubique.subset(c,ubique.end(c));\r\n  * // 3\r\n  * \r\n  * ubique.subset(a,0,1); \r\n  * // [ [ 6 ] ]\r\n  * \r\n  * ubique.subset(a,[0,1],[1,2]); \r\n  * // [ [ 6, 5 ], [ 8, -1 ] ]\r\n  * \r\n  * ubique.subset(a,0,':');\r\n  * [ [ 5, 6, 5 ] ]\r\n  * \r\n  * ubique.subset(a,':',0);\r\n  * [ [ 5 ], [ 7 ] ]\r\n  */\r\n  $u.subset = function(m,r,c) {\r\n    if (arguments.length === 0) {\r\n      throw new Error('not enough input arguments');\r\n    }\r\n    if (arguments.length > 3) {\r\n      throw new Error('too many input arguments');\r\n    }\r\n    if (arguments.length === 1) {\r\n      return m;\r\n    } \r\n    if (arguments.length === 2) {\r\n      if ($u.isnumber(m)) {\r\n        return m;\r\n      }\r\n      if ($u.isarray(m)) {\r\n        if ($u.isnumber(r)) {\r\n          return m[r];\r\n        } else {\r\n          return r.map(function(val) {return m[val];});\r\n        }\r\n      }\r\n    }\r\n    if (arguments.length === 3) {\r\n      if ($u.ismatrix(m)) {\r\n        if (r === ':') {\r\n          r = $u.colon(0,$u.nrows(m) - 1);\r\n        }\r\n        if (c === ':') {\r\n          c = $u.colon(0,$u.ncols(m) - 1);\r\n        }\r\n        if ($u.isnumber(r)) {\r\n          r = [r];\r\n        }\r\n        if ($u.isnumber(c)) {\r\n          c = [c];\r\n        }\r\n        if (r.length  === 1 && c.length === 1) {\r\n          out = [[0]];\r\n        } else {\r\n          out = $u.zeros(r.length,c.length);\r\n        }\r\n        for (var i = 0;i < r.length;i++) {\r\n          var tmp = r[i];\r\n          for (var j = 0;j < c.length;j++) {\r\n            out[i][j] = m[tmp][c[j]];\r\n          }\r\n        }\r\n        return $u.squeeze(out);\r\n      } else {\r\n        throw new Error('input must be a matrix');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/subsetlin.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n  /**\r\n   * @method  substelin\r\n   * @summary Subset of array or matrix based on linear indexing\r\n   * @description Subset of array or matrix based on linear indexing by rows (default)\r\n   *              \r\n   * @param  {array|matrix} m   array or matrix of elements \r\n   * @param  {numer|array|matrix} idx linear indexing\r\n   * @param  {number} flag flag 0: rowwise element, 1: columnwise (def: 0)\r\n   * @return {numner|array|matrix}     \r\n   *\r\n   * @example\r\n   * var a = [[5,6,5],[7,8,-1]];\r\n   * var c = [5,6,3];\r\n   *\r\n   * ubique.subsetlin(a,1);\r\n   * // [ 6 ]\r\n   *\r\n   * // subset by rows\r\n   * ubique.subsetlin(a,[0,1,2,3]);\r\n   * // [ 5, 6, 5, 7 ]\r\n   *\r\n   * // subset by columns\r\n   * ubique.subsetlin(a,[0,1,2,3],1);\r\n   * // [ 5, 7, 6, 8 ]\r\n   * \r\n   * ubique.subsetlin(a,[[0,1,2],[2,3,4]],1);\r\n   *  // [ [ 5, 7, 6 ], [ 6, 8, 5 ] ]\r\n   *  \r\n   * ubique.subsetlin(c,[0,1]);\r\n   * // [ 5, 6 ]\r\n   * \r\n   * ubique.subsetlin(c,[[0,1],[1,2]]);\r\n   * // [ [ 5, 6 ], [ 6, 3 ] ]\r\n   */\r\n   $u.subsetlin = function(m,idx,flag) {\r\n    if (arguments.length === 0) {\r\n      throw new Error('not enough input arguments');\r\n    }\r\n    if (arguments.length === 1 || $u.isnumber(m)) {\r\n      return m;\r\n    } \r\n    flag = flag == null ? 0 : flag;\r\n    if ($u.isnumber(idx)) {\r\n      idx = [idx];\r\n    }\r\n    var _m = $u.flatten(m,flag);\r\n    return $u.squeeze($u.arrayfun(idx,function(val){return _m[val]}));\r\n  }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/tomat.js":"/**\r\n* Array Creation and Concatenation\r\n*/\r\nmodule.exports = function($u) {\r\n/**\r\n * @method tomat\r\n * @summary Convert number or array to matrix\r\n * @description Convert number or array to matrix\r\n *              \r\n * @param  {number|array|boolean} x input\r\n * @return {matrix}     \r\n *\r\n * @example\r\n * ubique.tomat(5);\r\n * // [ [ 5 ] ]\r\n * \r\n * ubique.tomat([5,6,3]);\r\n * // [ [ 5, 6, 3 ] ]\r\n * \r\n */\r\n $u.tomat = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif ($u.isnumber(x) || $u.islogical(x)) {\r\n \t\treturn [[x]];\r\n \t} else\r\n \tif ($u.isarray(x)) {\r\n    return [x];\r\n  } else \r\n  if ($u.ismatrix(x)) {\r\n   return x;\r\n } else {\r\n   throw new Error('unknown input arguments');\r\n }\r\n\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/transpose.js":"/**\r\n * Sorting and Reshaping Arrays\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method transpose\r\n * @summary Transpose X.'\r\n * @description Transpose of matrix X. Array is 1xN as default. \r\n * Transpose of Array is Nx1 matrix.\r\n * \r\n * @param  {array|matrix} x array or matrix of elements\r\n * @return {matrix}\r\n *\r\n * @example\r\n * ubique.transpose([[5,6,5],[7,8,-1]]);\r\n * // [ [ 5, 7 ], [ 6, 8 ], [ 5, -1 ] ]\r\n * \r\n * ubique.transpose([5,6,3]);\r\n * // [ [ 5 ], [ 6 ], [ 3 ] ]\r\n */\r\n $u.transpose = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  var _transpose = function(a,acols,arows) {\r\n    var out = $u.matrix(acols,arows);\r\n    for (var i = 0;i < acols; i++) {\r\n      for (var j = 0;j < arows; j++) {\r\n        out[i][j] = a[j][i];\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return x;\r\n  }\r\n  if ($u.isarray(x)) {\r\n    return _transpose([x],x.length,1);\r\n  }\r\n  return _transpose(x,$u.ncols(x),$u.nrows(x));\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/trues.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method trues\r\n * @summary Create array of all true\r\n * @description Create array of all true\r\n * \r\n * @param  {number|array|...} args variable input arguments (max 2)\r\n * @return {number|matrix}     \r\n *\r\n * @example\r\n * ubique.trues(0);\r\n * // []\r\n * \r\n * ubique.trues(1);\r\n * // [ [ true ] ]\r\n * \r\n * ubique.trues(2);\r\n * // [ [ true, true ], [ true, true ] ]\r\n * \r\n * ubique.trues([2,1]);\r\n * // [ [ true ], [ true ] ]\r\n * \r\n * ubique.trues(2,3);\r\n * // [ [ true, true, true ], [ true, true, true ] ]\r\n */\r\n $u.trues = function() {\r\n  if (arguments.length === 0 ) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _args = $u.argsarray.apply(null,arguments);\r\n  if ($u.ismatrix(_args)) {\r\n    _args = _args[0];\r\n  }\r\n  if (_args.length === 1) {\r\n    _args = [_args[0],_args[0]];\r\n  }\r\n  return $u.matrix(_args,true);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/vertcat.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method vertcat\r\n * @summary Concatenate arrays or matrices vertically\r\n * @description Concatenate arrays or matrices vertically\r\n *              \r\n * @param  {array|matrix|...} args variable arguments (args1,args2,...)\r\n * @return {array|matrix}     \r\n *\r\n * @example\r\n * ubique.vertcat([[5,6,5],[7,8,-1]],[[-1,3,-1],[4,5,9]]);\r\n * // [ [ 5, 6, 5 ], [ 7, 8, -1 ], [ -1, 3, -1 ], [ 4, 5, 9 ] ]\r\n * \r\n * ubique.vertcat(5,7,9,8);\r\n * // [ 5, 7, 9, 8 ]\r\n */\r\n $u.vertcat = function() {\r\n  var _args = $u.argsarray.apply(null,arguments);\r\n  return $u.cat.apply(null,[].concat(0,_args));\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/matarrs/zeros.js":"/**\r\n * Array Creation and Concatenation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method zeros\r\n * @summary Create array or matrix of all zeros\r\n * @description Create array or matrix of all zeros\r\n * \r\n * @param  {number|array|...} args variable input arguments (max 2)\r\n * @return {number|matrix}     \r\n *\r\n  * @example\r\n * ubique.zeros(0);\r\n * // []\r\n * \r\n * ubique.zeros(1);\r\n * // [ [ 0 ] ]\r\n * \r\n * ubique.zeros(2);\r\n * // [ [ 0, 0 ], [ 0, 0 ] ]\r\n * \r\n * ubique.zeros([2,1]);\r\n * // [ [ 0 ], [ 0 ] ]\r\n * \r\n * ubique.zeros(2,3);\r\n * // [ [ 0, 0, 0 ], [ 0, 0, 0 ] ]\r\n */\r\n $u.zeros = function() {\r\n if (arguments.length === 0 ) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _args = $u.argsarray.apply(null,arguments);\r\n  if ($u.ismatrix(_args)) {\r\n    _args = _args[0];\r\n  }\r\n  if (_args.length === 1) {\r\n    _args = [_args[0],_args[0]];\r\n  }\r\n  return $u.matrix(_args,0);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/probdistr/jbtest.js":"/**\r\n * Distribution Tests\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method  jbtest\r\n * @summary Jarque-Bera test\r\n * @description  A test decition for the null hypothesis that the data \r\n * in array X comes from a normal distribution with an unknown mean and variance\r\n * \r\n * @param  {array} x array of values\r\n * @return {number}   \r\n *\r\n * @example\r\n * var x = [ 0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * \r\n * ubique.jbtest(x);\r\n * // 0.6360604293924916\r\n */\r\n $u.jbtest = function(x) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var n = x.length;\r\n  var s = $u.skewness(x);\r\n  var xk = $u.xkurtosis(x);\r\n  return (n/6) * (Math.pow(s,2) + Math.pow(xk,2)/4);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/probdistr/normcdf.js":"/**\r\n * Normal Distributions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method normcdf\r\n * @summary Normal cumulative distribution function (cdf)\r\n * @description The Standard Normal Distribution: mu = 0 and sigma = 1\r\n *\r\n * @param  {number} x number to calculate cdf\r\n * @param  {number} mu mean of  the array of elements\r\n * @param  {number} sigma standarf deviaton of array of elements\r\n * @return {number}\r\n *\r\n * @example\r\n * var x = [ 0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * \r\n * ubique.normcdf(2);\r\n * // 0.97725\r\n * \r\n * ubique.normcdf(0,ubique.mean(x),ubique.std(x));\r\n * // 0.22049\r\n */\r\n $u.normcdf = function(x,mu,sigma) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mu = mu == null ? 0 : mu;\r\n  sigma = sigma == null ? 1 : sigma;\r\n  return 0.5 * (1 + $u.erf((x - mu) / Math.sqrt(2 * sigma * sigma)));\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/probdistr/norminv.js":"/**\r\n * Normal Distributions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method norminv\r\n * @summary Inverse of the normal cumulative distribution function (cdf)\r\n * @description Returns the inverse cdf for the normal distribution with mean MU\r\n * and standard deviation SIGMA at P value\r\n *\r\n * Default values: MU = 0, SIGMA = 1\r\n * \r\n * @param  {number} p probability value in range [0,1]\r\n * @param  {number} mu mean value\r\n * @param  {number} sigma standard deviation \r\n * @return {number}       \r\n *\r\n * @example\r\n * var x = [ 0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n *\r\n * ubique.norminv(0.05);\r\n * // -1.64485\r\n * \r\n * ubique.norminv(0.01,ubique.mean(x),ubique.std(x));\r\n * // -0.0361422\r\n */\r\n $u.norminv = function(p,mu,sigma) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mu = mu == null ? 0 : mu;\r\n  sigma = sigma == null ? 1 : sigma;\r\n  if (p <= 0 || p >= 1) {\r\n    throw new Error('invalid input argument');\r\n  }\r\n  var x0 = -Math.sqrt(2) * $u.erfcinv(2 * p);\r\n  return x0 * sigma + mu;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/probdistr/normpdf.js":"/**\r\n * Normal Distributions\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method normpdf\r\n * @summary Normal probability density function (pdf)\r\n * @description  Normal probability density function (pdf).\r\n * Returns the pdf of the normal distribution with\r\n * mean MU and standard deviation SIGMA, evaluated at the values in X\r\n *\r\n * Default values: MU = 0, SIGMA = 1\r\n * \r\n * @param  {number} x real value\r\n * @param  {number} mu mean value (def: 0)\r\n * @param  {number} sigma standard deviation (def: 1)\r\n * @return {number}       \r\n *\r\n * @example\r\n * var x = [ 0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * \r\n * ubique.normpdf(1);\r\n * // 0.241971\r\n * \r\n * ubique.normpdf(0,ubique.mean(x),ubique.std(x));\r\n * // 12.7622\r\n */\r\n $u.normpdf = function(x,mu,sigma) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mu = mu == null ? 0 : mu;\r\n  sigma = sigma == null ? 1 : sigma;\r\n  return Math.exp(-0.5 * Math.pow((x - mu)/sigma,2)) / (Math.sqrt(2 * Math.PI) * sigma);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/activereturn.js":"/**\r\n * Performance metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method activereturn\r\n * @summary Active return\r\n * @description Asset/Portfolio annualized return minus Benchmark annualized return\r\n * \r\n * @param  {array|matrix} x asset/portfolio returns \r\n * @param  {array} y benchmark returns\r\n * @param  {number} t frequencey of data. 1: yearly, 4: quarterly, 12: monthly, 52: weekly, 252: daily\r\n * @param  {string} mode 'geometric' or 'simple' (def: 'geometric')\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var z = [0.04,-0.022,0.043,0.028,-0.078,-0.011,0.033,-0.049,0.09,0.087];\r\n * var cat = ubique.cat;\r\n *\r\n * ubique.activereturn(x,z,12);\r\n * // 0.041979\r\n *\r\n * ubique.activereturn(cat(0,x,y),z,12);\r\n * // [ [ 0.041979], [ -0.046746 ] ]\r\n */\r\n $u.activereturn = function(x,y,t,mode,dim) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  t = t == null ? 252 : t;\r\n  mode = mode == null ? 'geometric' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n  \r\n  var _activereturn = function(a,y,t,mode) {\r\n    return $u.annreturn(a,t,mode) - $u.annreturn(y,t,mode);\r\n  }\r\n  if ($u.isnumber(x) || $u.isnumber(y)) {\r\n    throw new Error('input must be an array or matrix');\r\n  }\r\n  return $u.vectorfun(dim,x,_activereturn,y,t,mode);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/adjsharpe.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method adjsharpe\r\n * @summary Adjusted Sharpe Ratio\r\n * @description Sharpe Ratio adjusted for skewness and kurtosis with a penalty factor \r\n * for negative skewness and excess kurtosis.\r\n *\r\n * Adjusted Sharpe ratio = SR x [1 + (S/6) x SR - ((K-3) / 24) x SR^2]\r\n * SR = sharpe ratio\r\n * K = kurtosis\r\n * S = skewness\r\n * \r\n * @param  {array|matrix} x array of value\r\n * @param  {number} frisk annual free-risk rate (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.adjsharpe(x,0.02/12);\r\n * // 0.748134\r\n * \r\n * ubique.adjsharpe(cat(0,x,y));\r\n * // [ [ 0.830583, 0.245232 ] ]\r\n */\r\n $u.adjsharpe = function(x,frisk,dim) {\r\n  if (arguments.length === 0) {\r\n   throw new Error('not enough input arguments');\r\n }\r\n frisk = frisk == null ? 0 : frisk;\r\n dim = dim == null ? 0 : dim;\r\n\r\n var _asharpe = function(a,frisk) {\r\n   var sr = $u.sharpe(a,frisk);\r\n   var sk = $u.skewness(a);\r\n   var ku = $u.kurtosis(a);\r\n   return sr * (1 + (sk/6) * sr - ((ku - 3)/24) * Math.sqrt(sr));\r\n }\r\n if ($u.isnumber(x)) {\r\n   return NaN;\r\n }\r\n return $u.vectorfun(dim,x,_asharpe,frisk);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/annadjsharpe.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method annadjsharpe\r\n * @summary Annualized Adjusted Sharpe Ratio\r\n * @description Sharpe Ratio adjusted for skewness and kurtosis with a penalty factor \r\n * for negative skewness and excess kurtosis.\r\n *\r\n * Adjusted Sharpe ratio = SR x [1 + (S/6) x SR - ((K-3) / 24) x SR^2]\r\n * SR = sharpe ratio with annualized return/risk\r\n * K = kurtosis\r\n * S = skewness\r\n * \r\n * @param  {array|matrix} x array of value\r\n * @param  {number} frisk annual free-risk rate (def: 0)\r\n * @param  {number} t frequency 252: daily (default), 52: weekly, 12: monthly, 4: quarterly\r\n * @param  {string} mode 'geometric' or 'simple' (def: 'geometric')\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.annadjsharpe(x,0.02,12,'geometric');\r\n * // 3.376724\r\n * \r\n * ubique.annadjsharpe(cat(0,x,y),0,12);\r\n * // [ [ 3.766555, 0.827757 ] ]\r\n */\r\n $u.annadjsharpe = function(x,frisk,t,mode,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  t = t == null ? 252 : t;\r\n  mode = mode == null ? 'geometric' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _asharpe = function(a,frisk,t,mode) {\r\n   var aret = $u.annreturn(a,t,mode),\r\n   arisk = $u.annrisk(a,t),\r\n   sr = (aret - frisk) / arisk,\r\n   sk = $u.skewness(a),\r\n   ku = $u.kurtosis(a);\r\n   return sr * (1 + (sk/6) * sr - ((ku - 3)/24) * Math.sqrt(sr));\r\n }\r\n if ($u.isnumber(x)) {\r\n   throw NaN;\r\n }\r\n return $u.vectorfun(dim,x,_asharpe,frisk,t,mode);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/annreturn.js":"/**\r\n * Performance metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method annreturn\r\n * @summary Annualized Return\r\n * @description Average annualized returns over a period, convenient when comparing returns.\r\n * It can be an Arithmetic or Geometric (default) average return: if compounded with itself the\r\n * geometric average will be equal to the cumulative return\r\n * \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} t frequencey of data. 1: yearly, 4: quarterly, 12: monthly, 52: weekly, 252: daily\r\n * @param  {string} mode 'geometric' or 'simple' (def: 'geometric')\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.annreturn(x,12);\r\n * // 0.233815\r\n *\r\n * ubique.annreturn(cat(0,x,y),12);\r\n * // [ [ 0.233815 ], [ 0.14509 ] ]\r\n */\r\n $u.annreturn = function(x,t,mode,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tt = t == null ? 252 : t;\r\n  mode = mode == null ? 'geometric' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _annreturn = function(arr,t,mode) {\r\n    var n = arr.length;\r\n    if (mode === 'geometric') {\r\n      return $u.power($u.prod($u.plus(1,arr)),(t/n)) - 1;\r\n    } else\r\n    if (mode === 'simple') {\r\n      return $u.mean(arr) * t;\r\n    } else {\r\n      throw new Error('unknown mode');\r\n    }\r\n  }\r\n \t if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_annreturn,t,mode);\r\n }\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/annrisk.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method annrisk\r\n * @summary Annualized Risk\r\n * @description Annualized standard deviation of asset/portfolio returns\r\n * \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} t frequencey of data. 1: yearly, 4: quarterly, 12: monthly, 52: weekly, 252: daily\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.annrisk(x,12);\r\n * // 0.080473\r\n *\r\n * ubique.annrisk(cat(0,x,y),12);\r\n * // [ [ 0.080473 ], [ 0.182948 ] ]\r\n */\r\n $u.annrisk = function(x,t,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tt = t == null ? 252 : t;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n \tvar _annrisk = function(a,t) {\r\n \t\treturn Math.sqrt(t) * $u.std(a);\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn NaN;\r\n \t}\r\n \treturn $u.vectorfun(dim,x,_annrisk,t);\r\n }\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/avgdrawdown.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method avgdrawdown\r\n * @summary Average drawdown\r\n * @description Average drawdown or average K-largest drawdown\r\n * \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} k largest drawdown. k = 0 for all continuous drawdown (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {object}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n * \r\n * // average drawdown\r\n * ubique.avgdrawdown(x);\r\n * // 0.0115\r\n *\r\n * // 1-largest drawdown\r\n * ubique.avgdrawdown(x,1);\r\n * // 0.014\r\n * \r\n * ubique.avgdrawdown(cat(0,x,y));\r\n * // [ [ 0.0115 ], [ 0.056571 ] ]\r\n */\r\n $u.avgdrawdown = function(x,k,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  k = k == null ? 0 : k;\r\n  dim = dim == null ? 0 : dim;\r\n  \r\n  var avgdd = function(a,k) {\r\n    var cdd =  $u.cdrawdown(a);\r\n    if (k === 0) {\r\n      return $u.mean(cdd);\r\n    } else\r\n    if (k > 0 && k <= cdd.length) {\r\n      var cdds = $u.sort(cdd,'descend');\r\n      return $u.mean($u.subsetlin(cdds,$u.colon(0,k - 1)));\r\n    } else {\r\n      return NaN;\r\n    }\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return 0;\r\n  }\r\n  return $u.vectorfun(dim,x,avgdd,k);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/burkeratio.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method burkeratio\r\n * @summary Burke Ratio\r\n * @description A risk-adjusted measure with free risk and drawdowns.\r\n * For the 'simple' mode the excess return over free risk is divided by the square root of \r\n * the sum of the square of the drawdowns. For the 'modified' mode the Burke Ratio is multiplied\r\n * by the square root of the number of datas.\r\n *  \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} frisk annual free-risk rate (def: 0)\r\n * @param  {number} t frequency 252: daily (default), 52: weekly, 12: monthly, 4: quarterly\r\n * @param  {string} mode 'simple' or 'modified' (def: 'simple')\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|arrray}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n *\r\n * ubique.burkeratio(x,0,12);\r\n * // 14.048563\r\n *\r\n * ubique.burkeratio(x,0,12,'modified');\r\n * // 44.425456\r\n *\r\n * ubique.burkeratio(cat(0,x,y),0,12);\r\n * // [ [ 14.048563 ], [ 1.228487 ] ]\r\n */\r\n $u.burkeratio = function(x,frisk,t,mode,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  t = t == null ? 252 : t;\r\n  mode = mode == null ? 'simple' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n  \r\n  var _burkeratio = function(a,frisk,t,mode) {\r\n    var annret = $u.annreturn(a,t),\r\n    dd = $u.sqrt($u.sum($u.power($u.cdrawdown(a),2)));\r\n    if (mode === 'simple') {\r\n      return (annret - frisk) / dd;\r\n    } else\r\n    if (mode === 'modified') {\r\n      return (annret - frisk) / dd * $u.sqrt(a.length);\r\n    } else {\r\n      throw new Error('unknown mode');\r\n    }\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    throw new Error('input arguments must be an array or matrix');\r\n  }\r\n  return $u.vectorfun(dim,x,_burkeratio,frisk,t,mode);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/cagr.js":"/**\r\n * Performance metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method cagr\r\n * @summary Compound annual growth rate\r\n * @description Compound annual growth rate\r\n * \r\n * @param  {number|array|matrix} x portfolio/assets returns \r\n * @param  {number} p number of years (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n *\r\n * // CAGR for 10 months on 12 or 0.83 years\r\n * ubique.cagr(x,x.length/12);\r\n * // 0.229388\r\n *\r\n * ubique.cagr(cat(0,x,y),x.length/12);\r\n * // [ [ 0.229388 ], [ 0.151999 ] ]\r\n */\r\n $u.cagr = function(x,p,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  p = p == null ? 1 : p;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _cagr = function(a,p) {\r\n    return $u.power(1 + $u.ror(a,'ret'),(1 / p)) - 1;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n   return $u.power(a,(1 / p)) - 1;\r\n  }\r\n  return $u.vectorfun(dim,x,_cagr,p);\r\n }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/calmarratio.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method calmarratio\r\n * @summary Calmar Ratio\r\n * @description A risk-adjusted measure like Sharpe ratio that uses maximum drawdown instead of\r\n * standard deviation for risk.\r\n *  \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} frisk annual free-risk rate (def: 0)\r\n * @param  {number} t frequencey of data. 1: yearly, 4: quarterly, 12: monthly, 52: weekly, 252: daily (def: 252)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|arrray}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.calmarratio(x,0,12);\r\n * // 16.701049\r\n *\r\n * ubique.calmarratio(cat(0,x,y),0,12);\r\n * // [ [ 16.701049 ], [ 1.32768 ] ]\r\n */\r\n $u.calmarratio = function(x,frisk,t,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  t = t == null ? 252 : t;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _calmarratio = function(a,frisk,t) {\r\n    var annret = $u.annreturn(a,t),\r\n    maxdd = $u.drawdown(a).maxdd;\r\n    return (annret - frisk) / maxdd;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    throw new Error('input arguments must be an array or matrix');\r\n  }\r\n  return $u.vectorfun(dim,x,_calmarratio,frisk,t);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/cdrawdown.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method cdrawdown\r\n * @summary Continuous Drawdown\r\n * @description Continuous Drawdown\r\n *  \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {array|matrix}\r\n * \r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * ubique.cdrawdown(x);\r\n * // [ 0.009, 0.014 ]\r\n * \r\n * ubique.cdrawdown(ubique.cat(0,x,y));\r\n * // [ [ 0.009, 0.014 ], [ 0.005, 0.095743, 0.068971 ] ]\r\n */\r\n $u.cdrawdown = function(x,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _cdown = function(a) {\r\n    var cdd = [], tmp = 0, t = 0;\r\n    for (var i = 0; i < a.length; i++) {\r\n      if (i === 0 && a[i] < 0) {\r\n        tmp = 1 + a[i];\r\n      }\r\n      if (i > 0) {\r\n        if (a[i] < 0) {\r\n          if (tmp === 0) {\r\n            tmp = 1 + a[i];\r\n          } else {\r\n            tmp = tmp * (1 + a[i]);\r\n          }\r\n        }\r\n        if (a[i] >=0) {\r\n          if (tmp !== 0) {\r\n            cdd[t] = 1 - tmp;\r\n            t++;\r\n            tmp = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (tmp !== 0) {\r\n      cdd.push(1 - tmp);\r\n      tmp = 0;\r\n    }\r\n    return cdd;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return 0;\r\n  }\r\n  return $u.vectorfun(dim,x,_cdown);\r\n\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/downsidepot.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method downsidepot\r\n * @summary Downside potential\r\n * @description Downside potential\r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number} mar minimum acceptable return (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * ubique.downsidepot(x,0.1/100);\r\n * // 0.0025\r\n * \r\n * ubique.downsidepot(ubique.cat(0,x,y));\r\n * // [ [ 0.0023 ], [ 0.0173 ] ]\r\n */\r\n $u.downsidepot = function(x,mar,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n   mar = mar == null ? 0 : mar;\r\n   dim = dim == null ? 0 : dim;\r\n   \r\n   var _ddp = function(a,mar) {\r\n    var z = 0;\r\n    for (var i = 0;i < a.length;i++) {\r\n      z += Math.max(mar - a[i],0) / a.length;\r\n    }\r\n    return z;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n   return x;\r\n }\r\n return $u.vectorfun(dim,x,_ddp,mar);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/downsiderisk.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method downsiderisk\r\n * @summary Downside Risk\r\n * @description Downside Risk or Semi-Standard Deviation. \r\n * Measures  the  variability  of  underperformance  below  a  minimum  target   rate \r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number} mar minimum acceptable return (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * ubique.downsiderisk(x,0.1/100);\r\n * // 0.00570088\r\n * \r\n * ubique.downsiderisk(ubique.cat(0,x,y));\r\n * // [ [ 0.005263 ], [ 0.028208 ] ]\r\n */\r\n $u.downsiderisk = function(x,mar,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mar = mar == null ? 0 : mar;\r\n  dim = dim == null ? 0 : dim;\r\n  \r\n  var _dsrisk = function(a,mar) {\r\n    var z = 0;\r\n    for (var i = 0; i < a.length; i++) {\r\n      z += Math.pow(Math.min(a[i] - mar,0),2) / a.length;\r\n    }\r\n    return Math.sqrt(z);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return x;\r\n  }\r\n  return $u.vectorfun(dim,x,_dsrisk,mar);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/drawdown.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method drawdown\r\n * @summary Drawdown\r\n * @description Drawdowon from Peak.Any continuous losing return period.\r\n * Return drawdown from peak and time to recovery array.\r\n *\r\n * Returns an object with:\r\n *\r\n * dd (drawdown array)\r\n * ddrecov (drawdown recovery index)\r\n * maxdd (max drawdown)\r\n * maxddrecov (max drawdown recovery period): [start period, end period]\r\n * \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {string} mode drawdown calculation. 'return','geometric' (def: 'return')\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {object}  \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n *\r\n * ubique.drawdown(x);\r\n * // { dd: [ 0, 0, 0, 0.009, 0, 0, 0, 0, 0.014, 0 ], ddrecov: [ 0, 0, 0, 4, 0, 0, 0, 0, 9, 0 ],\r\n * //   maxdd: 0.014, maxddrecov: [ 8, 9 ] }\r\n */\r\n $u.drawdown = function(x,mode,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mode = mode == null ? 'return' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n  \r\n  var ddown = function(a,mode) {\r\n    if (mode === 'return') {\r\n      _a = $u.cumprod($u.plus(a,1));\r\n    } else\r\n    if (mode === 'geometric') {\r\n      _a = $u.log($u.cumprod($u.plus(a,1)));\r\n    } else {\r\n      throw new Error('unknown drawdown mode');\r\n    }\r\n    var highest = _a[0],\r\n    highestidx = 1,\r\n    _dd = $u.array(_a.length,0),\r\n    _recov = $u.array(_a.length,0),\r\n    _maxdd = 0,\r\n    _maxddidx = [1,_a.length],\r\n    _cdd = [],\r\n    t = 0;\r\n    _cdd[t] = 0;\r\n    for (var i = 0; i < _a.length; i++) {\r\n      if (highest <= _a[i]) {\r\n        highest = _a[i];\r\n        highestidx = i + 1;\r\n      }\r\n      if (mode === 'return') {\r\n        _dd[i] = (highest - _a[i]) / highest;\r\n      } else \r\n      if (mode === 'geometric') {\r\n        _dd[i] = (highest - _a[i]);\r\n      }\r\n      if (_dd[i] !== 0) {\r\n        _recov[i] = i + 1;\r\n      }\r\n      if (_dd[i] > _maxdd) {\r\n        _maxdd = _dd[i];\r\n        _maxddidx[0] = highestidx;\r\n        _maxddidx[1] = i + 1;\r\n      }\r\n    }\r\n    return {dd: _dd, ddrecov: _recov, maxdd: _maxdd, maxddrecov: _maxddidx};\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return 0;\r\n  }\r\n  return $u.vectorfun(dim,x,ddown,mode);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/histcondvar.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method histcondvar\r\n * @summary Historical Conditional Value-At-Risk\r\n * @description Historical Conditional Value-At-Risk. Univariate historical simulation.Single asset\r\n * \r\n * @param  {array|matrix} x array or matrix of values    \r\n * @param  {number} p confidence level in the range [0,1] (def: 0.95)\r\n * @param  {number} amount amount (def: 1)\r\n * @param  {period} period time horizon (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)    \r\n * @return {number|array}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * // historical daily conditional VaR at 95% conf level\r\n * ubique.histcondvar(ubique.cat(0,x,y),0.95);\r\n * // [ [ 0.014 ], [ 0.061 ] ]\r\n *\r\n * // historical daily conditional VaR at 99% for 100k GBP asset over 10 days \r\n * ubique.histcondvar(ubique.cat(0,x,y),0.99,100000,10);\r\n * // [ [ 4427.188724 ], [ 19289.893727 ] ]\r\n */\r\n $u.histcondvar = function(x,p,amount,period,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  p = p == null ? 0.95 : p;\r\n  amount = amount == null ? 1 : amount;\r\n  period = period == null ? 1 : period;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _hcvar = function(a,p,amount,period) {\r\n    var _VaR = -$u.histvar(a,p),\r\n    z = [],\r\n    t = 0;\r\n    for (var i = 0; i < a.length; i++) {\r\n      if (a[i] <= _VaR) {\r\n        z[t] = a[i];\r\n        t++;\r\n      }\r\n    }\r\n    return -$u.mean(z) * Math.sqrt(period) * amount;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n   return x;\r\n }\r\n return $u.vectorfun(dim,x,_hcvar,p,amount,period);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/histvar.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method histvar\r\n * @summary Historical Value-At-Risk\r\n * @description Univariate historical simulation. Single asset\r\n * \r\n * @param  {array|matrix} x array or matrix of values    \r\n * @param  {number} p confidence level in the range [0,1] (def: 0.95)\r\n * @param  {number} amount amount (def: 1)\r\n * @param  {period} period time horizon (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)    \r\n * @return {number|array}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * // historical daily VaR at 95% conf level\r\n * ubique.histvar(ubique.cat(0,x,y),0.95);\r\n * // [ [ 0.014 ], [ 0.061 ] ]\r\n *\r\n * // historical daily VaR at 99% for 100k GBP asset over 10 days \r\n * ubique.histvar(ubique.cat(0,x,y),0.99,100000,10);\r\n * // [ [ 4427.188724 ], [ 19289.893727 ] ]\r\n */\r\n $u.histvar = function(x,p,amount,period,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  p = p == null ? 0.95 : p;\r\n  amount = amount == null ? 1 : amount;\r\n  period = period == null ? 1 : period;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _histvar = function(a,p,amount,period) {\r\n    return -$u.quantile(a,1 - p) * Math.sqrt(period) * amount;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n   return x;\r\n }\r\n return $u.vectorfun(dim,x,_histvar,p,amount,period);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/hurst.js":"/**\r\n * Time Series Analysis\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method hurst\r\n * @summary Hurst index/exponent\r\n * @description It's a useful statistic for detecting if a time series is mean reverting (anti-persistent), totally random or persistent.\r\n * A value in the range [0.5) indicates mean-reverting (anti-persistent)\r\n * A value of 0.5 indicate a random walk\r\n * A value H in the range (0.5,1] indicates momentum (persistent)\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} flag normalization value 0: population, 1:sample (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * ubique.hurst(x);\r\n * // 0.344059\r\n * \r\n * ubique.hurst(x,1);\r\n * // 0.3669383\r\n * \r\n * ubique.hurst(ubique.cat(0,x,y));\r\n * // [ [ 0.344059 ], [ 0.51531 ] ]\r\n */\r\n $u.hurst = function(x,flag,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  flag = flag == null ? 1 : flag;\r\n  dim = dim == null ? 0 : dim;\r\n  var _hurst = function(a,flag) {\r\n    var cdev = $u.cumdev(a);\r\n    var rs = ($u.max(cdev) - $u.min(cdev)) / $u.std(a,flag);\r\n    return Math.log(rs) / Math.log(a.length);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n   return 0;\r\n }\r\n return $u.vectorfun(dim,x,_hurst,flag); \r\n\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/inforatio.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method inforatio\r\n * @summary Information Ratio\r\n * @description Information Ratio\r\n * \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {array} y benchmark returns\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|matrix}      \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var z = [0.04,-0.022,0.043,0.028,-0.078,-0.011,0.033,-0.049,0.09,0.087];\r\n *\r\n * ubique.inforatio(x,y);\r\n * // 0.0936915\r\n * \r\n * ubique.inforatio(ubique.cat(0,x,y),z);\r\n * // [ [ 0.026302 ], [ -0.059705 ] ]\r\n */\r\n $u.inforatio = function(x,y,dim) {\r\n   if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim = dim == null ? 0 : dim;\r\n  var _ir = function(a,b) {\r\n    return $u.mean($u.minus(a,b)) / $u.std($u.minus(a,b));\r\n  }\r\n  if ($u.isarray(x) && $u.isarray(y)) {\r\n    return  _ir(x,y);\r\n  } else\r\n  if ($u.ismatrix(x) && $u.isarray(y)) {\r\n    return $u.vectorfun(dim,x,_ir,y);\r\n  } else {\r\n   throw new Error('first input must be an array/matrix, the second one an array');\r\n }\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/irr.js":"/**\r\n * Performance metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method irr\r\n * @summary Internal rate of return on an investment based on a series of periodic cash flows\r\n * @description Calculates the internal rate of return on an investment\r\n * based on a series of regularly/irregurarly periodic cash flows.\r\n * \r\n * @param  {array} cf income or payments associated with the investment. Must contain at least one negative and one positive cash flow to calculate rate of return, and the first amount must be negative\r\n * @param  {array} cfd number of calendar days from the beginning of the period that cash flow occurs\r\n * @param  {number} cd total number of calendar days in the measurement period\r\n * @param  {number} guess estimate for what the internal rate of return will be (def: 0.1)\r\n * @return {number}       \r\n *\r\n * @example\r\n * //Simple IRR\r\n * ubique.irr([250000,25000,-10000,-285000]);\r\n * // 0.024712563094781776\r\n * \r\n * ubique.irr([74.2,37.1,-104.4],[0,1,2],2);\r\n * // -0.07410820570460687\r\n *\r\n * //Modified IRR\r\n * ubique.irr([250000,25000,-10000,-285000],[0,45,69,90],90);\r\n * // 0.07692283872311274\r\n * \r\n * ubique.irr([74.2,37.1,-104.4],[0,14,31],31);\r\n * // -0.07271456460699813\r\n */\r\n $u.irr = function(cf,cfd,cd,guess) {\r\n   if (arguments.length < 1) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var _npv = function(cf,cfd,cd,guess) {\r\n    var npv = 0;\r\n    for (var i = 0;i < cf.length;i++) {\r\n      npv += cf[i] / Math.pow((1 + guess),cfd[i]/cd);\r\n    }\r\n    return npv;\r\n  }\r\n  var _npvd = function(cf,cfd,cd,guess) {\r\n    var npv = 0;\r\n    for (var i = 0;i < cf.length;i++) {\r\n      npv -= cfd[i]/cd * cf[i] / Math.pow((1 + guess),cfd[i]/cd)\r\n    }\r\n    return npv;\r\n  }\r\n  if (arguments.length === 1) {\r\n    cfd = $u.colon(0,cf.length-1,1);\r\n    cd = 1;\r\n    guess = 0.1;\r\n  }\r\n  if (arguments.length === 2) {\r\n    cd = 1;\r\n    guess = 0.1;\r\n  }\r\n  if (arguments.length === 3) {\r\n    guess = 0.1;\r\n  }\r\n  var rate = guess,\r\n  maxeps = 1e-6,\r\n  maxiter = 50,\r\n  newrate = 0,\r\n  epsrate = 0,\r\n  npv = 0,\r\n  cnt = 0,\r\n  cntv = true;\r\n  do {\r\n    npv = _npv(cf,cfd,cd,rate);\r\n    newrate = rate - npv / _npvd(cf,cfd,cd,rate);\r\n    epsrate = Math.abs(newrate - rate);\r\n    rate = newrate;\r\n    cntv = (epsrate > maxeps) && (Math.abs(npv) > maxeps);\r\n  } while (cntv && (cnt++ < maxiter));\r\n  if (cntv) {\r\n    throw new Error('number error');\r\n  }\r\n  return rate;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/jensenalpha.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method jensenalpha\r\n * @summary Jensen alpha\r\n * @description  Ex-post alpha calculated with regression line. Free-risk is the avereage free-risk for the timeframe selected.\r\n *\r\n * @param  {array|matrix} x asset/portfolio values\r\n * @param  {array} y benchmark values\r\n * @param  {number} frisk  free-risk (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|matrix}      \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var z = [0.04,-0.022,0.043,0.028,-0.078,-0.011,0.033,-0.049,0.09,0.087];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.jensenalpha(x,y);\r\n * // 0.017609\r\n * \r\n * ubique.jensenalpha(cat(0,x,y),z);\r\n * // [ [ 0.020772 ], [ 0.006256 ] ]\r\n */\r\n $u.jensenalpha = function(x,y,frisk,dim) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _ja = function(a,b,frisk) {\r\n    var beta = $u.linearreg(a,b).beta;\r\n    return $u.mean(a) - frisk - beta * ($u.mean(b) - frisk);\r\n  }\r\n  if ($u.isarray(x) && $u.isarray(y)) {\r\n    return  _ja(x,y,frisk);\r\n  } else\r\n  if ($u.ismatrix(x) && $u.isarray(y)) {\r\n    return $u.vectorfun(dim,x,_ja,y,frisk);\r\n  } else {\r\n    throw new Error('first input must be an array/matrix, the second one an array');\r\n  }\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/m2sortino.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method m2sortino\r\n * @summary M-squared for Sortino\r\n * @description M2 calculated for Downside risk instead of Total Risk\r\n *  \r\n * @param  {array|matrix} x asset/portfolio values\r\n * @param  {array} y benchmark values\r\n * @param  {number} frisk free-risk rate (def: 0)\r\n * @param  {number} mar minimum acceptable return (def: 0)\r\n * @param  {number} t frequencey of data. 1: yearly, 4: quarterly, 12: monthly, 52: weekly, 252: daily (def: 252)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|matrix}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var z = [0.04,-0.022,0.043,0.028,-0.078,-0.011,0.033,-0.049,0.09,0.087];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.m2sortino(x,y,0,0,12);\r\n * // 0.103486\r\n * \r\n * ubique.m2sortino(cat(0,x,y),z,0,0,12);\r\n * // [ [ 0.527018 ], [ 0.148094 ] ]\r\n */\r\n $u.m2sortino = function(x,y,frisk,mar,t,dim) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  mar = mar == null ? 0 : mar;\r\n  t = t == null ? 252 : t;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _m2sortino = function(a,b,frisk,mar,t) {\r\n    return $u.annreturn(a,t) + $u.sortino(a,frisk,mar) * ($u.downsiderisk(b,mar) * $u.sqrt(t) - $u.downsiderisk(a,mar) * $u.sqrt(t));\r\n  }\r\n  if ($u.isarray(x) && $u.isarray(y)) {\r\n    return  _m2sortino(x,y,frisk,mar,t);\r\n  } else\r\n  if ($u.ismatrix(x) && $u.isarray(y)) {\r\n    return $u.vectorfun(dim,x,_m2sortino,y,frisk,mar,t);\r\n  } else {\r\n    throw new Error('first input must be an array/matrix, the second one an array');\r\n  }\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/martinratio.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method martinratio\r\n * @summary Martin Ratio\r\n * @description A risk-adjusted measure with free risk and Ulcer index.\r\n * \r\n * Martin Ratio = (Portfolio Return - RiskFree) / Ulcer Index\r\n *  \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} frisk annual free-risk rate (def: 0)\r\n * @param  {number} t frequencey of data. 1: yearly, 4: quarterly, 12: monthly, 52: weekly, 252: daily (def: 252)\r\n * @param  {string} mode drawdown calculation. 'return','geometric' (def: 'return')\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|arrray}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n *\r\n * ubique.martinratio(x,0,12);\r\n * // 44.425456\r\n *\r\n * ubique.martinratio(cat(0,x,y),0,12);\r\n * // [ [ 44.425456 ], [ 2.438364 ] ]\r\n */\r\n $u.martinratio = function(x,frisk,t,mode,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  t = t == null ? 252 : t;\r\n  mode = mode == null ? 'return' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _martinratio = function(a,frisk,t,mode) {\r\n    var annret = $u.annreturn(a,t),\r\n    dd = $u.sqrt($u.sum($u.power($u.cdrawdown(a),2)));\r\n    return (annret - frisk) /$u.ulcerindex(a,mode);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    throw new Error('input arguments must be an array or matrix');\r\n  }\r\n  return $u.vectorfun(dim,x,_martinratio,frisk,t,mode);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/mdietz.js":"/**\r\n * Performance metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method mdietz\r\n * @summary Historical performance of an investment portfolio with external cash flows\r\n * @description Historical performance of an investment portfolio with external cash flows\r\n * \r\n * @param  {number} ev ending value\r\n * @param  {number} bv beginning market value\r\n * @param  {number|array} cf external cashflows (inflows/outflows)\r\n * @param  {number|array} cfd number of calendar days from the beginning of the period that cash flow occurs\r\n * @param  {number} cd total number of calendar days in the measurement period\r\n * @return {number}\r\n *\r\n * @example\r\n * var ev = 104.4,bv = 74.2,cf = 37.1,cfd = 14, cd = 31;\r\n * ubique.mdietz(ev,bv,cf,cfd,cd);\r\n * // -0.07298099559862156\r\n *\r\n * var ev = 1200,bv = 1000,cf = [10,50,35,20],cfd = [15,38,46,79],cd = 90;\r\n * ubique.mdietz(ev,bv,cf,cfd,cd);\r\n * // 0.0804\r\n */\r\n $u.mdietz = function(ev,bv,cf,cfd,cd) {\r\n  if (arguments.length < 5) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var md = -99999;\r\n  var w = [];\r\n  if ($u.isnumber(cf)) {\r\n    md = (ev - bv - cf) / (bv + (cf * (1 - cfd / cd)));\r\n  } else {\r\n    if (cd <= 0) {\r\n      throw new Error('actual number of days in the period negative or zero');\r\n    }\r\n    for (var i = 0;i < cf.length;i++) {\r\n      if (cfd[i] < 0) {\r\n        throw new Error('number of days negative or zero');\r\n      }\r\n      w[i] = (1 - cfd[i] / cd);\r\n    }\r\n      var ttwcf = 0; //total weighted cash flows\r\n      for (var i = 0;i < cf.length;i++) {\r\n        ttwcf += w[i] * cf[i];\r\n      }\r\n      var tncf = 0; //total net cash flows\r\n      for (var i = 0;i < cf.length;i++) {\r\n        tncf += cf[i];\r\n      }\r\n      md = (ev - bv - tncf) / (bv + ttwcf);\r\n    }\r\n    return md;\r\n  }\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/modigliani.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method modigliani\r\n * @summary Modigliani index for risk-adjusted return\r\n * @description Modigliani index for risk-adjusted return\r\n *  \r\n * @param  {array|matrix} x asset/portfolio values\r\n * @param  {array} y benchmark values\r\n * @param  {number} frisk free-risk rate (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|matrix}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var z = [0.04,-0.022,0.043,0.028,-0.078,-0.011,0.033,-0.049,0.09,0.087];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.modigliani(x,y);\r\n * // 0.0406941\r\n * \r\n * ubique.modigliani(cat(0,x,y),z);\r\n * // [ [ 0.042585 ], [ 0.013185 ] ]\r\n */\r\n $u.modigliani = function(x,y,frisk,dim) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _m2 = function(a,b,frisk) {\r\n    return $u.mean(a) + $u.sharpe(a,frisk) * ($u.std(b) - $u.std(a));\r\n  }\r\n  if ($u.isarray(x) && $u.isarray(y)) {\r\n    return  _m2(x,y,frisk);\r\n  } else\r\n  if ($u.ismatrix(x) && $u.isarray(y)) {\r\n    return $u.vectorfun(dim,x,_m2,y,frisk);\r\n  } else {\r\n    throw new Error('first input must be an array/matrix, the second one an array');\r\n  }\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/montecarlovar.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method  montecarlovar\r\n * @summary Montecarlo Value-at-Risk\r\n * @description Montecarlo VaR for single asset. Based on geometric Brownian motion.\r\n *\r\n * @param  {number|array} x array of returns or standard deviation of returns\r\n * @param  {number} p confidence level in the range [0,1] (def: 0.95)\r\n * @param  {number} t holding period (def: 1)\r\n * @param  {number} fr free-risk rate (def: 0)\r\n * @param  {number} v asset/portfolio start value (def: 1)\r\n * @param  {number} iter number of iterations\r\n * @return {number}  \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n *\r\n * // ex-ante simulated VaR at 95% confidence for t = 1, free risk zero, start capital one\r\n * ubique.montecarlovar(x,0.95,1,0,1,10000);\r\n * // 0.073219\r\n * \r\n * // historical simulated daily VaR at 99% for 100k GBP asset over 10 days \r\n * ubique.montecarlovar(ubique.std(x),0.99,10,0,100000);\r\n * // 25254.640005\r\n */\r\n $u.montecarlovar = function(x,p,t,fr,v,iter) {\r\n   if (arguments.length === 0) {\r\n    return null;\r\n  }\r\n  p = p == null ? 0.95 : p;\r\n  t = t == null ? 1 : t;\r\n  fr = fr == null ? 0 : fr;\r\n  v = v == null ? 1 : v;\r\n  iter = iter == null ? 10000 : iter;\r\n  if ($u.isnumber(x)) {\r\n    s = $u.clone(x);\r\n  } else \r\n  if ($u.isarray(x)) {\r\n    s = $u.std(x);\r\n  } else {\r\n    throw new Error('first argument must be a number or array');\r\n  }\r\n  var mcvar = [];\r\n  for (var i = 0;i < iter;i++) {\r\n    mcvar[i] = Math.exp((fr - 0.5 * Math.pow(s,2)) + s * $u.norminv(Math.random(),0,1)) - 1;\r\n  }\r\n  return - Math.pow(t,0.5) * $u.prctile(mcvar, 1 - p) * v;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/omegaratio.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method omegaratio\r\n * @summary Omega ratio\r\n * @description Omega ratio\r\n * \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} mar minimum acceptable return (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * ubique.omegaratio(x);\r\n * // 8.782609\r\n * \r\n * ubique.omegaratio(ubique.cat(0,x,y));\r\n * // [ [ 8.782609 ], [ 1.728324 ] ]\r\n */\r\n $u.omegaratio = function(x,mar,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mar = mar == null ? 0 : dim;\r\n  dim = dim == null ? 0 : dim;\r\n  var _or = function(a,mar) {\r\n    return $u.upsidepot(a,mar) / $u.downsidepot(a,mar);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_or,mar);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/painindex.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method painindex\r\n * @summary Pain Index\r\n * @description Mean value of the drawdowns, similar to Ulcer Index.\r\n *  \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {string} mode drawdown calculation. 'return','geometric' (def: 'return')\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array} \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.painindex(x);\r\n * // 0.0023\r\n * \r\n * ubique.painindex(cat(0,x,y));\r\n * // [ [ 0.0023 ], [ 0.042955 ] ]\r\n */\r\n $u.painindex = function(x,mode,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mode = mode == null ? 'return' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _painindex = function(a,mode) {\r\n    dd = $u.drawdown(a,mode).dd,\r\n    n = a.length;\r\n    return $u.sum(dd) / n;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_painindex,mode);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/painratio.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method painratio\r\n * @summary Pain Ratio\r\n * @description A risk-adjusted measure with free risk and Pain index.\r\n * \r\n * Pain Ratio = (Portfolio Return - RiskFree) / Pain Index\r\n *  \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} frisk annual free-risk rate (def: 0)\r\n * @param  {number} t frequencey of data. 1: yearly, 4: quarterly, 12: monthly, 52: weekly, 252: daily (def: 252)\r\n * @param  {string} mode drawdown calculation. 'return','geometric' (def: 'return')\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|arrray}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n *\r\n * ubique.painratio(x,0,12);\r\n * // 101.044955\r\n *\r\n * ubique.painratio(cat(0,x,y),0,12);\r\n * // [ [ 101.044955 ], [ 3.235687 ] ]\r\n */\r\n $u.painratio = function(x,frisk,t,mode,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  t = t == null ? 252 : t;\r\n  mode = mode == null ? 'geometric' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n \r\n  var _painratio = function(a,frisk,t,mode) {\r\n    var annret = $u.annreturn(a,t);\r\n    var dd = $u.sqrt($u.sum($u.power($u.cdrawdown(a),2)));\r\n    return (annret - frisk) /$u.painindex(a,mode);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    throw new Error('input arguments must be an array or matrix');\r\n  }\r\n  return $u.vectorfun(dim,x,_painratio,frisk,t,mode);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/paramcondvar.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method paramcondvar\r\n * @summary Parametric Conditional Value-At-Risk\r\n * @description Parametric Conditional Value-At-Risk. More sensitive to the shape of the loss distribution in the tails\r\n * Also known as Expected Shortfall (ES), Expected Tail Loss (ETL).\r\n * \r\n * @param  {number|array} mu mean value (def: 0)\r\n * @param  {number|array} sigma standard deviation (def: 1)\r\n * @param  {number} p cVaR confidende level in range [0,1] (def: 0.95)\r\n * @param  {number} amount portfolio/asset amount (def: 1)\r\n * @param  {number} period time horizon (def: 1)\r\n * @return {number}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * // parametric daily Var at 95% conf level\r\n * ubique.paramcondvar(ubique.mean(x),ubique.std(x));\r\n * // 0.030018\r\n *\r\n * //parametric daily VaR at 99% for 100k GBP asset over 10 days (two assets)\r\n * ubique.paramcondvar(ubique.mean(ubique.cat(0,x,y)),ubique.std(ubique.cat(0,x,y)),0.99,100000,10);\r\n * // [ [ 19578.980844 ], [ 44511.107219 ] ]\r\n */\r\n $u.paramcondvar = function(mu,sigma,p,amount,period) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  p = p == null ? 0.95 : p;\r\n  amount = amount == null ? 1 : amount;\r\n  period = period == null ? 1 : period;\r\n  \r\n  var _pcvar = function(_mu,_sigma,p,amount,period) {\r\n    return _sigma * $u.normpdf($u.norminv(1 - p))/(1 - p) * amount * Math.sqrt(period) - _mu;\r\n  }\r\n  if ($u.isnumber(mu)) {\r\n    return _pcvar(mu,sigma,p,amount,period);\r\n  }\r\n  var temp = $u.flatten(mu);\r\n  var out = temp.map(function(el,idx) {\r\n    return _pcvar(mu[idx],sigma[idx],p,amount,period);\r\n  });\r\n  if ($u.ismatrix(mu) && $u.isrow(mu)) {\r\n    return [out];\r\n  }\r\n  if ($u.ismatrix(mu) && $u.iscolumn(mu)) {\r\n    return $u.transpose(out);\r\n  }\r\n  return out;\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/paramvar.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method paramvar\r\n * @summary Parametric Value-At-Risk\r\n * @description Parametric Value-At-Risk. Assets or portfolio returns are normally distributed.\r\n * It manages numbers, arrays, row vectors [[a,b,...,n]] and column vectors [[a],[b],...,[n]]\r\n * \r\n * @param  {number|array} mu mean value (def: 0)\r\n * @param  {number|array} sigma standard deviation (def: 1)\r\n * @param  {number} p VaR confidende level in range [0,1] (def: 0.95)\r\n * @param  {number} amount portfolio/asset amount (def: 1)\r\n * @param  {number} period time horizon (def: 1)\r\n * @return {number}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * // VaR with numbers\r\n * ubique.paramvar(0,1);\r\n * // 1.644854\r\n *\r\n * // VaR with arrays\r\n * ubique.paramvar([0,0,0],[1,2,3]);\r\n * [ 1.644854, 3.289707, 4.934561 ]\r\n * \r\n * // parametric VaR at 95% conf level\r\n * ubique.paramvar(ubique.mean(x),ubique.std(x));\r\n * // 0.020311\r\n * \r\n * ubique.paramvar(ubique.mean(ubique.cat(0,x,y)),ubique.std(ubique.cat(0,x,y)));\r\n * // [ [ 0.020311 ], [ 0.074269 ] ]\r\n *\r\n * //parametric VaR at 99% for 100k GBP asset over 10 days (two assets)\r\n * ubique.paramvar(ubique.mean(ubique.cat(0,x,y)),ubique.std(ubique.cat(0,x,y)),0.99,100000,10);\r\n * // [ [ 11429.165523 ], [ 34867.319072 ] ]\r\n */\r\n $u.paramvar = function(mu,sigma,p,amount,period) {\r\n \tif (arguments.length < 2) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tp = p == null ? 0.95 : p;\r\n  amount = amount == null ? 1 : amount;\r\n  period = period == null ? 1 : period;\r\n\r\n  var _pvar = function(_mu,_sigma,p,amount,period) {\r\n    return (-$u.norminv(1 - p) * _sigma - _mu) * Math.sqrt(period) * amount; \r\n  }\r\n  if ($u.isnumber(mu)) {\r\n    return _pvar(mu,sigma,p,amount,period);\r\n  }\r\n  var temp = $u.flatten(mu);\r\n  var out = temp.map(function(el,idx) {\r\n    return _pvar(mu[idx],sigma[idx],p,amount,period);\r\n  });\r\n  if ($u.ismatrix(mu) && $u.isrow(mu)) {\r\n    return [out];\r\n  }\r\n  if ($u.ismatrix(mu) && $u.iscolumn(mu)) {\r\n    return $u.transpose(out);\r\n  }\r\n  return out;\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/percpos.js":"/**\r\n * Performance metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method percpos\r\n * @summary Percentage of positive values in array or matrix\r\n * @description Percentage of positive values in array or matrix\r\n * \r\n * @param  {array|matrix} x array of elements\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * ubique.percpos(x);\r\n * // 0.8\r\n * \r\n * ubique.percpos(ubique.cat(0,x,y));\r\n * // [ [ 0.8 ], [ 0.5 ] ]\r\n * \r\n * ubique.percpos(ubique.cat(0,x,y),1);\r\n * // [ [ 0.5, 1, 1, 0, 0.5, 1, 0.5, 0.5, 0.5, 1 ] ]\r\n */\r\n $u.percpos = function(x,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _percpos = function(a) {\r\n    var count = 0;\r\n    for (var i = 0;i < a.length;i++) {\r\n      if (a[i] >= 0) {\r\n        count++;\r\n      } \r\n    }\r\n    return count / a.length;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_percpos);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/ret2tick.js":"/**\r\n * Data Transformation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method ret2tick\r\n * @summary Convert a return series to a value series with a start value\r\n * @description  Convert a return series to a value series with a start value\r\n * \r\n * @param  {array|matrix} x array of elements\r\n * @param  {string} mode method to compute returns. 'simple','continuous' (def: simple)\r\n * @param  {number} sval start value (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {array|matrix}     \r\n *\r\n * @example\r\n * ubique.ret2tick([0.5,-3,2.3],'simple',100);\r\n * // [ 100, 150, -300, -990 ]\r\n * \r\n * ubique.ret2tick([[9, 5], [6, 1]],'simple',100);\r\n * // [ [ 100, 1000, 6000 ], [ 100, 700, 1400 ] ]\r\n */\r\n $u.ret2tick = function(x,mode,sval,dim) {\r\n   if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mode = mode == null ? 'simple' : mode;\r\n  sval = sval == null ? 1 : sval;\r\n  dim = dim == null ? 0 : dim;\r\n  \r\n  var _ret2tick = function(a,mode,sval) {\r\n    if ($u.isnumber(a)) {\r\n      a = [a];\r\n    }\r\n    var r = [];\r\n    r[0] = sval;\r\n    if (mode === 'simple') {\r\n      for (var i = 1; i <= a.length; i++) {\r\n        r[i] = r[i - 1] * (1 + a[i - 1]);\r\n      }\r\n    } else \r\n    if (mode === 'continuous') {\r\n      for (var i = 1; i <= a.length; i++) {\r\n        r[i] = r[i - 1] * Math.exp(a[i - 1]);\r\n      }\r\n    } else {\r\n      throw new Error('unknown return method');\r\n    }\r\n    return r;\r\n  }\r\n  return $u.vectorfun(dim,x,_ret2tick,mode,sval);\r\n  \r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/ror.js":"/**\r\n * Performance metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method ror\r\n * @summary Simple rate of return\r\n * @description Simple rate of return calculated from the last and the first value of \r\n * an array of numbers.\r\n * \r\n * @param  {array|matrix} x array or matrix of returns or values\r\n * @param  {string} mode mode of values, 'ret' for returns, 'cum' for cumulative (def: 'ret')\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.ror(x);\r\n * // 0.187793\r\n * \r\n * ubique.ror([100,101,99,98,97,102,103,104],'cum');\r\n * // 0.04\r\n * \r\n * ubique.ror(cat(0,x,y),'ret');\r\n * // [ [ 0.187793 ], [ 0.125149 ] ]\r\n */\r\n $u.ror = function(x,mode,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mode = mode == null ? 'ret' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _ror = function(a,mode) {\r\n    if (mode === 'ret') {\r\n      var eq = $u.cumprod($u.plus(1,a));\r\n    } else\r\n    if (mode === 'cum') {\r\n      var eq = $u.clone(a);\r\n    } else {\r\n      throw  new Error('unknown value');\r\n    }\r\n    return eq[eq.length - 1] / eq[0] - 1;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_ror,mode);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/sharpe.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method sharpe\r\n * @summary Sharpe Ratio\r\n * @description Sharpe Ratio.Compute Sharpe ratio for an array X of values (daily, weekly, etc) and\r\n * a free-risk rate. Annual free-risk must be divided to match the right timeframe.\r\n * \r\n * @param  {array|matrix} x array of value\r\n * @param  {number} frisk annual free-risk rate (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|arrray}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * ubique.sharpe(x,0.02/12);\r\n * // 0.698794\r\n * \r\n * ubique.sharpe(ubique.cat(0,x,y));\r\n * // [ [ 0.770539 ], [ 0.23858 ] ]\r\n */\r\n $u.sharpe = function(x,frisk,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  frisk = frisk == null ? 0 : frisk;\r\n  dim = dim == null ? 0 : dim;\r\n \r\n \tvar _sharpe = function(a,frisk) {\r\n \t\treturn ($u.mean(a) - frisk) / $u.std(a);\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn NaN;\r\n \t}\r\n \treturn $u.vectorfun(dim,x,_sharpe,frisk);\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/sortino.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method sortino\r\n * @summary Sortino ratio\r\n * @description  Sortino ratio\r\n * \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} frisk free-risk rate (def: 0)\r\n * @param  {number} mar minimum acceptable return (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 1)\r\n * @return {number|arrray}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * ubique.sortino(x,0.02/12);\r\n * // 3.08438\r\n * \r\n * ubique.sortino(ubique.cat(0,x,y),0.01/12,0.5);\r\n * // [ [ 0.035364 ], [ 0.024015 ] ]\r\n */\r\n $u.sortino = function(x,frisk,mar,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  mar = mar == null ? 0 : mar;\r\n  dim = dim == null ? 0 : dim;\r\n  \r\n  var _sr = function(a,frisk,mar) {\r\n    return ($u.mean(a) - frisk) / $u.downsiderisk(a,mar);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_sr,frisk,mar);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/sterlingratio.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method sterlingratio\r\n * @summary Sterling Ratio\r\n * @description A risk-adjusted measure like Calmar ratio but the denominator is \r\n * the largest consecutive drawdown (excluded the 10% excess in the original formula)\r\n * \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {number} frisk annual free-risk rate (def: 0)\r\n * @param  {number} t frequencey of data. 1: yearly, 4: quarterly, 12: monthly, 52: weekly, 252: daily (def: 252)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.sterlingratio(x,0,12);\r\n * // 16.701049\r\n *\r\n * ubique.sterlingratio(cat(0,x,y),0,12);\r\n * // [ [ 16.701049 ], [ 1.515412 ] ]\r\n */\r\n $u.sterlingratio = function(x,frisk,t,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  t = t == null ? 252 : t;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _sterlingratio = function(a,frisk,t) {\r\n    var annret = $u.annreturn(a,t);\r\n    var ldd = $u.max($u.cdrawdown(a));\r\n    return (annret - frisk) / ldd;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_sterlingratio,frisk,t);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/tick2ret.js":"/**\r\n * Data Transformation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method tick2ret\r\n * @summary Convert a value series to a return series\r\n * @description  Convert a value series to a return series. 'simple' (default) for simple returns, 'continuous' for continuously compounded\r\n * \r\n * @param  {array|matrix} x array of elements\r\n * @param  {string} mode method to compute returns. 'simple','continuous' (def: simple)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {array|matrix}     \r\n *\r\n * @example\r\n * ubique.tick2ret([0.5,-3,2.3]);\r\n * // [ -7, -1.766667 ]\r\n * \r\n * ubique.tick2ret([[9, 5], [6, 1]]);\r\n * // [ [ -0.444444 ], [ -0.833333 ] ]\r\n */\r\n $u.tick2ret = function(x,mode,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mode = mode == null ? 'simple' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n  \r\n  if ($u.numel(x) < 2) {\r\n    throw new Error('insert at least two values');\r\n  }\r\n  var _tick2ret = function(a,mode) {\r\n    var r = [];\r\n    if (mode === 'simple') {\r\n      for (var i = 1;i < a.length;i++) {\r\n        r[i - 1] = a[i] / a[i - 1] - 1;\r\n      }\r\n    } else \r\n    if (mode === 'continuous') {\r\n      for (var i = 1;i < a.length;i++) {\r\n        r[i - 1] = Math.log(a[i] / a[i - 1]);\r\n      }\r\n    } else {\r\n      throw new Error('unkwon retun method');\r\n    }\r\n    return r;\r\n  }\r\n  return $u.vectorfun(dim,x,_tick2ret,mode);\r\n  \r\n}\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/tomonthly.js":"/**\r\n * Time Series Analysis\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method tomonthly\r\n * @summary Convert a time series to a monthly frequency\r\n * @description Convert a time series to a monthly frequency. Default: all days\r\n * in the range.\r\n *\r\n * @param  {array} nd array of unix dates\r\n * @param  {array|matrix} nv array or matrix of values\r\n * @return {matrix}\r\n *\r\n * @example\r\n * ubique.tomonthly(ubique.datenum(['15-01-18','15-02-28','15-03-05','15-03-24','15-04-27'],'YY-MM-DD'),[100,99,102,103,98]);\r\n * // [ [ 1421539200, 1425081600, 1427155200, 1430092800 ], [ 100, 99, 103, 98 ] ]\r\n */\r\n $u.tomonthly = function(nd,nv) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  // basic mode: all data, exact on last day of month\r\n  var md = $u.month(nd);\r\n  var df = $u.diff(md);\r\n  df[0] = 1;\r\n  df = $u.cat(1,df,1)[0];\r\n  var idx = $u.find(df.map(function(el){return el !== 0;}));\r\n  if ($u.isarray(nv)) {\r\n    var newv = $u.subset(nv,idx);\r\n  }\r\n  if ($u.ismatrix(nv)) {\r\n    var newv = $u.subset(nv,idx,':');\r\n  }\r\n  return [$u.subset(nd,idx),newv];\r\n\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/toweekly.js":"/**\r\n * Time Series Analysis\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method toweekly\r\n * @summary Convert a time series to a weekly frequency\r\n * @description Convert a time series to a weekly frequency. Default: all days\r\n * in the range. Example: daily dates [Wed,...Fri,...Mon,...Fri,...Thu] will become \r\n * [Wed,...,Fri...,Fri...,Thu]\r\n *\r\n * @param  {array} nd array of unix dates\r\n * @param  {array|matrix} nv array or matrix of values\r\n * @return {matrix}\r\n *\r\n * @example\r\n * ubique.toweekly(ubique.datenum(['15-01-15','15-01-23','15-01-30','15-02-04'],'YY-MM-DD'),[100,99,102,103,98]);\r\n * // [ [ 1421280000, 1421971200, 1422576000, 1423008000 ],[ 100, 99, 102, 103 ] ]\r\n */\r\n $u.toweekly = function(nd,nv) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var wd = $u.weekday(nd);\r\n\r\n  // basic mode: all data, exact on Friday\r\n  var idx = $u.find(wd.map(function(a) {return a === 5;}));\r\n  if (wd[0] !== 5) {\r\n    idx = $u.cat(1,0,idx);\r\n  }\r\n  if (wd[wd.length - 1] !== 5) {\r\n    idx = $u.cat(1,idx,nd.length - 1)[0];\r\n  }\r\n  if ($u.isarray(nv)) {\r\n    var newv = $u.subset(nv,idx);\r\n  }\r\n  if ($u.ismatrix(nv)) {\r\n    var newv = $u.subset(nv,idx,':');\r\n  }\r\n  return [$u.subset(nd,idx),newv];\r\n\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/trackerr.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method trackerr\r\n * @summary Tracking Error (ex-post)\r\n * @description  Ex-post tracking error\r\n * \r\n * @param  {array|matrix} x array or matrix of X values\r\n * @param  {array} y array of Y values\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var z = [0.04,-0.022,0.043,0.028,-0.078,-0.011,0.033,-0.049,0.09,0.087];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.trackerr(x,z);\r\n * // 0.068436\r\n *\r\n * ubique.trackerr(cat(0,x,y),z);\r\n * // [ [ 0.068436 ], [ 0.058622 ] ]\r\n */\r\n $u.trackerr = function(x,y,dim) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim = dim == null ? 0 : dim;\r\n  var _te = function(a,b) {\r\n    return $u.std($u.minus(a,b));\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_te,y);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/treynor.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method treynor\r\n * @summary Treynor Ratio\r\n * @description Compute the Treynor ratio for an array X of values (daily, weekly, etc) and\r\n * a free-risk rate. Annual free-risk must be divided to match the right timeframe.\r\n * \r\n * @param  {array} x array of X values\r\n * @param  {array} y array of Y values\r\n * @param  {number} frisk  free-risk rate (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number}       \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * var z = [0.04,-0.022,0.043,0.028,-0.078,-0.011,0.033,-0.049,0.09,0.087];\r\n * var cat = ubique.cat;\r\n * \r\n * ubique.treynor(x,z,0.01/12);\r\n * // -0.095687\r\n *\r\n * ubique.treynor(cat(0,x,y),z,0.01/12);\r\n * // [ [ -0.095687 ], [ 0.029863 ] ]\r\n */\r\n $u.treynor = function(x,y,frisk,dim) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  frisk = frisk == null ? 0 : frisk;\r\n  dim = dim == null ? 0 : dim;\r\n  var _treynor = function(a,b,frisk) {\r\n    var beta = $u.linearreg(a,b).beta;\r\n    return ($u.mean(a) - frisk) / beta;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_treynor,y,frisk);\r\n\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/twr.js":"/**\r\n * Performance metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method twr\r\n * @summary True Time-weighted return measures the returns of the assets irrespective of the amount invested\r\n * @description rue Time-weighted return measures the returns of the assets irrespective of the amount invested\r\n * \r\n * @param  {array} mv array of market values\r\n * @param  {array} cf array of external cashflows (inflows/outflows)\r\n * @return {number}    \r\n *\r\n * @example\r\n * var mv = [250000,255000,257000,288000,293000,285000], cf = [0,0,25000,0,-10000,0];\r\n * \r\n * ubique.twr(mv,cf);\r\n * // 0.07564769566198049\r\n */\r\n $u.twr = function(mv,cf) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if (arguments.length === 1) {\r\n    cf = 0;\r\n  }\r\n  if (mv.length !== cf.length) {\r\n    throw new Error('market value and cash flows must be of the same size');\r\n  }\r\n  var _twr = [1];\r\n  for (var i = 1; i < mv.length; i++) {\r\n    _twr[i] = mv[i] / (mv[i - 1] + cf[i - 1]);\r\n  }\r\n  return $u.prod(_twr) - 1;\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/ulcerindex.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method ulcerindex\r\n * @summary Ulcer Index\r\n * @description Ulcer Index of Peter G. Martin (1987). The impact of long, deep drawdowns will have significant\r\n * impact because the underperformance since the last peak is squared.\r\n *  \r\n * @param  {array|matrix} x asset/portfolio returns\r\n * @param  {string} mode drawdown calculation. 'return','geometric' (def: 'return')\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array} \r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var xt = [[0.003,0.026],[0.015,-0.009],[0.014,0.024],[0.015,0.066],[-0.014,0.039]];\r\n * ubique.ulcerindex(x);\r\n * // 0.005263\r\n * \r\n * ubique.ulcerindex(xt,'return',1);\r\n * // [ [ 0.006261, 0.004025 ] ]\r\n */\r\n $u.ulcerindex = function(x,mode,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mode = mode == null ? 'return' : mode;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _uidx = function(a,mode) {\r\n    var dd = $u.drawdown(a,mode).dd;\r\n    var n = a.length;\r\n    return $u.sqrt($u.sum($u.power(dd,2)) / n);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_uidx,mode);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/quants/upsidepot.js":"/**\r\n * Risk metrics\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method upsidepot\r\n * @summary Upside potential\r\n * @description Upside potential\r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number} mar minimum acceptable return (def: 0)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 1)\r\n * @return {number|array}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * ubique.upsidepot(x,0.1/100);\r\n * // 0.0194\r\n * \r\n * ubique.upsidepot(ubique.cat(0,x,y));\r\n * // [ [ 0.0202 ], [ 0.0299 ] ]\r\n */\r\n $u.upsidepot = function(x,mar,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mar = mar == null ? 0 : mar;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _usp = function(a,mar) {\r\n    var z = 0;\r\n    for (var i = 0;i < a.length;i++) {\r\n      z += Math.max(a[i] - mar,0) / a.length;\r\n    }\r\n    return z;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_usp,mar);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/reglin/interp1.js":"/**\r\n * Interpolation\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method interp1\r\n * @summary Linear interpolation\r\n * @description Linear interpolation. Returns the 1-D value of Y, given Xi query points. \r\n * \r\n * @param  {array} x sample points\r\n * @param  {array} y corresponding values of sample points\r\n * @param  {number|array} new query points. For values outside [min(X),max(X)] NaN is returned.\r\n * @return {array}\r\n *\r\n * @example\r\n * var x = [1,2,3,4,5,6];\r\n * var y = [2,4,6,8,10,12];\r\n * var xnew = [2,4,6];\r\n *\r\n * ubique.interp1(x,y,xnew);\r\n * // [ 4, 8, 12 ]\r\n */\r\n $u.interp1 = function(x,y,xnew) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if (x.length !== y.length) {\r\n    throw new Error('input dimension mismatch');\r\n  }\r\n  if ($u.isnumber(xnew)) {\r\n    xnew = [xnew];\r\n  }\r\n  var ynew = new Array(xnew.length),\r\n  n = x.length,\r\n  dx = new Array(n),\r\n  dy = new Array(n),\r\n  slope = new Array(n),\r\n  intercept = new Array(n);\r\n\r\n  for (var i = 0; i < n; i++) {\r\n    if (i < n - 1) {\r\n      dx[i] = x[i + 1] - x[i];\r\n      dy[i] = y[i + 1] - y[i];\r\n      slope[i] = dy[i] / dx[i];\r\n      intercept[i] = y[i] - x[i] * slope[i];\r\n    } else {\r\n      dx[i] = dx[i - 1];\r\n      dy[i] = dy[y - 1];\r\n      slope[i] = slope[i - 1];\r\n      intercept[i] = intercept[i - 1];      \r\n    }\r\n  }\r\n\r\n  for (var j = 0; j < xnew.length; j++) {\r\n    if (xnew[j] < $u.min(x) || xnew[j] > $u.max(x)) {\r\n      ynew[j] = NaN;\r\n    } else {\r\n      var idx = findneighb(xnew[j],x);\r\n      ynew[j] = slope[idx] * xnew[j] + intercept[idx];\r\n    }\r\n  }\r\n  if ($u.numel(ynew) === 1) {\r\n    return ynew[0];\r\n  } else {\r\n    return ynew;\r\n  }\r\n}\r\nvar findneighb = function(value,arr) {\r\n  var dist = $u.maxval,\r\n  idx = -1;\r\n  for (var i = 0; i < arr.length; i++) {\r\n    var newdist = value - arr[i];\r\n    if (newdist > 0 && newdist < dist) {\r\n      dist = newdist;\r\n      idx = i;\r\n    }\r\n  }\r\n  return idx;\r\n}\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/reglin/linearreg.js":"/**\r\n * Linear Regression\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method  linearreg\r\n * @summary Linear regression of Y on X\r\n * @description Return an object with fields: Beta, Alpha, R-squared, function\r\n * \r\n * @param  {array} y array of elements in Y\r\n * @param  {array} x array of elements in X\r\n * @return {object} \r\n *\r\n * @example\r\n * var x = [ 0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * ubique.linearreg(x,y);\r\n * // { beta: 0.02308942571228251, alpha: 0.017609073236025237, rsq: 0.0027553853574994254, fun: [Function] }\r\n * \r\n * ubique.linearreg([100,101,99,102,105],[1,2,3,4,5])\r\n * // { beta: 1.1, alpha: 98.1, rsq: 0.5707547169811321, fun: [Function] }\r\n * \r\n * ubique.linearreg([100,101,99,102,105],[1,2,3,4,5]).fun(6);\r\n * // 104.69\r\n * \r\n */\r\n $u.linearreg = function(y,x) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  var n = y.length,\r\n  sx = $u.sum(x),\r\n  sy = $u.sum(y),\r\n  sxy = $u.sum($u.times(x,y)),\r\n  sxx = $u.sum($u.times(x,x)),\r\n  syy = $u.sum($u.times(y,y)),\r\n  beta = (n * sxy - sx * sy) / (n * sxx - sx * sx),\r\n  alpha = (sy - beta * sx) / n,\r\n  rsq = Math.pow((n *sxy - sx * sy)/Math.sqrt((n * sxx - sx * sx) * (n * syy - sy * sy)),2);\r\n  return {beta: beta,alpha: alpha, rsq: rsq,fun: function (x) {return beta * x + alpha;} }\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/corrcoef.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method corrcoef\r\n * @summary Correlation coefficients of two arrays X,Y\r\n * @description Correlation coefficients of two arrays X,Y\r\n *\r\n * @param  {array|matrix} x array or matrix of elemnts X\r\n * @param  {array|matrix} y array or matrix of elements Y\r\n * @param  {number} flag Bessel's correction 0: population, 1: sample (def: 1)\r\n * @return {matrix}\r\n *\r\n * @example\r\n * var c = [5,6,3];\r\n * var d = [0.5,-3,2.3];\r\n * var l = [[1,1,-1],[1,-2,3],[2,3,1]];\r\n *\r\n * ubique.corrcoef(l);\r\n * // [ [ 1, 0.802955, 0 ],[ 0.802955, 1, -0.59604 ],[ 0, -0.59604, 1 ] ]\r\n * \r\n * ubique.corrcoef(c,d);\r\n * // [ [ 1, -0.931151 ], [ -0.931151, 1 ] ]\r\n */\r\n $u.corrcoef = function(x) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tvar _args = [x];\r\n \tfor (var i = 1; i < arguments.length; i++) {\r\n \t\t_args.push(arguments[i]);\r\n \t}\r\n \tvar covm = $u.cov.apply(null,_args);\r\n \tvar sigma = $u.transpose($u.sqrt($u.diag(covm)));\r\n \tvar m = sigma.length;\r\n \tcovm = $u.rdivide(covm,$u.repmat(sigma,1,m));\r\n \tcovm = $u.rdivide(covm,$u.repmat($u.transpose(sigma),m,1));\r\n \treturn covm;\r\n }\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/cov.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method cov\r\n * @summary Covariance matrix\r\n * @description Covariance matrix\r\n *\r\n * @param  {array|matrix} x array or matrix of elemnts X\r\n * @param  {array|matrix} y array or matrix of elements Y\r\n * @param  {number} flag Bessel's correction 0: population, 1: sample (def: 1)\r\n * @return {number|array}\r\n *\r\n * @example\r\n * var c = [5,6,3];\r\n * var d = [0.5,-3,2.3];\r\n * var e = [[9, 5], [6, 1]];\r\n * var f = [[3, 2], [5, 2]];\r\n * var l = [[1,1,-1],[1,-2,3],[2,3,1]];\r\n *\r\n * ubique.cov(c);\r\n * // 2.33333\r\n * \r\n * ubique.cov(c,d);\r\n * // [ [ 2.333333, -3.833333 ], [ -3.833333, 7.263333 ] ]\r\n * \r\n * ubique.cov(c,d,0);\r\n * // [ [ 1.555556, -2.555556 ], [ -2.555556, 4.842222 ] ]\r\n\r\n * ubique.cov(e,f);\r\n * // [ [ 10.916667, 2 ], [ 2, 2 ] ]\r\n * \r\n * ubique.cov(l);\r\n * // [ [ 0.333333, 1.166667, 0 ],[ 1.166667, 6.333333, -3 ],[ 0, -3, 4 ] ]\r\n */\r\n $u.cov = function(x) {\r\n  var arglen = arguments.length;\r\n \tif (arglen === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif (arglen > 3) {\r\n \t\tthrow new Error('too many input arguments');\r\n \t}\r\n \tif (arglen === 3) {\r\n \t\tflag = arguments[arglen - 1];\r\n \t\tvar flagrule = $u.isscalar(flag) && (flag === 0 || flag === 1);\r\n \t\tif (!flagrule) {\r\n \t\t\tthrow new Error('third input must be 0 or 1');\r\n \t\t}\r\n \t\targlen = arglen - 1;\r\n \t} else\r\n \tif (arglen === 2 && $u.isscalar(arguments[arglen - 1]) && (arguments[arglen - 1] === 0 || arguments[arglen - 1] === 1)) {\r\n \t\t\tflag = arguments[arglen - 1];\r\n \t\t\targlen = arglen - 1;\r\n \t} else {\r\n \t\tflag = 1;\r\n \t}\r\n\r\n    if (arglen === 1 && ($u.isarray(x) || $u.isvector(x))) {\r\n    \tx = $u.flatten(x);\r\n    \treturn $u.varc(x);\r\n    }\r\n \tif (arglen === 2) {\r\n \t\ty = arguments[1];\r\n \t\tx = $u.transpose($u.flatten(x));\r\n \t\ty = $u.transpose($u.flatten(y));\r\n \t\tif (x.length !== y.length) {\r\n \t\t\tthrow new Error('input dimension must agree');\r\n \t\t}\r\n \t\tx = $u.cat(1,x,y);\r\n \t}\r\n \tvar m = $u.nrows(x);\r\n \tvar mu = $u.mean(x,1);\r\n \tvar z = $u.minus(x,$u.repmat(mu,m,1));\r\n \treturn $u.rdivide($u.mtimes($u.transpose(z),z), m - flag);\r\n }\r\n\r\n}\r\n\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/histc.js":"/**\r\n * Basic Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method histc\r\n * @summary Histogram count\r\n * @description  For array X counts the number of values in X that fall between the elements in the BINS array. Values outside the range in BINS are not counted.\r\n * \r\n * Returns an object with:\r\n * \r\n * bins - number of bins\r\n * count - number of matched elements\r\n * freq - frequency \r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number|array} bins number of bins (as NUMBER) or array of edges (as ARRAY) (def: 10)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {aray|matrix}       \r\n *\r\n * @example\r\n * var A = [87,27,45,62,3,52,20,43,74,61];\r\n * var B = [12,34,57,43,88,75,89,2,27,29];\r\n * \r\n * ubique.histc(A,[0,20,40,60,80,100]);\r\n * // [ { bins: 0, count: 1, freq: 0.1 },\r\n * //   { bins: 20, count: 2, freq: 0.2 },\r\n * //   { bins: 40, count: 3, freq: 0.3 },\r\n * //   { bins: 60, count: 3, freq: 0.3 },\r\n * //   { bins: 80, count: 1, freq: 0.1 },\r\n * //   { bins: 100, count: 0, freq: 0 } ]\r\n *\r\n * ubique.histc(ubique.cat(0,A,B),[0,50,100]);\r\n * // [ [ { bins: 0, count: 5, freq: 0.5 },\r\n * //     { bins: 50, count: 5, freq: 0.5 },\r\n * //     { bins: 100, count: 0, freq: 0 } ],\r\n * //   [ { bins: 0, count: 6, freq: 0.6 },\r\n * //     { bins: 50, count: 4, freq: 0.4 },\r\n * //     { bins: 100, count: 0, freq: 0 } ] ]\r\n */\r\n $u.histc = function(x,bins,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  bins = bins == null ? 10 : bins;\r\n  dim  = dim == null ? 0 : dim;\r\n\r\n  var _histc = function(a,bins) {\r\n    var y = [];\r\n    var h = []; \r\n    var out = [];\r\n    if ($u.isnumber(bins)) {\r\n      var xmin = $u.min(a),\r\n      xmax = $u.max(a),\r\n      binw = (xmax - xmin) / bins,\r\n      anum = $u.colon(0,bins);\r\n      y = $u.plus($u.times(anum,binw),xmin);\r\n    } else {\r\n      y = bins;\r\n    }\r\n\r\n    for (var k = 0; k < y.length; k++) {\r\n      h[k] = 0;\r\n      for (var i = 0; i < a.length; i++) {\r\n        if (y[k] <= a[i] && a[i] < y[k + 1]) {\r\n          h[k] += 1;\r\n        } else \r\n        if (a[i] === y[k]) {\r\n          h[k] += 1;\r\n        }\r\n      }\r\n      out.push({bins: y[k], count: h[k], freq: h[k]/a.length})\r\n    }\r\n    return out;\r\n  }\r\n\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_histc,bins);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/iqr.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method iqr\r\n * @summary Interquartile range\r\n * @description Return the interquartile (Q3 - Q1 quartiles)\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * var x = [ 0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * ubique.iqr(x);\r\n * // 0.023\r\n * \r\n * ubique.iqr(ubique.cat(0,x,y));\r\n * // [ [ 0.023 ], [ 0.095 ] ]\r\n */\r\n $u.iqr = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tdim  = dim == null ? 0 : dim;\r\n\r\n \tvar _iqr = function(a) {\r\n \t\treturn $u.prctile(a,75) - $u.prctile(a,25);\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn NaN;\r\n \t}\r\n \treturn $u.vectorfun(dim,x,_iqr);\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/kurtosis.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method kurtosis\r\n * @summary Kurtosis\r\n * @description Kurtosis\r\n * \r\n * @param  {array|matrix} x array or matrix of elements\r\n * @param  {number} flag 0: bias correction, 1: simple (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * ubique.kurtosis(x);\r\n * // 3.037581\r\n * \r\n * ubique.kurtosis(ubique.cat(0,x,y));\r\n * // [ [ 3.037581 ], [ 1.397642 ] ]\r\n */\r\n $u.kurtosis = function(x,flag,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  flag = flag == null ? 1 : flag;\r\n  dim  = dim == null ? 0 : dim;\r\n\r\n  var _kurtosis = function(a,flag) {\r\n    var n = a.length;\r\n    var mom4 = $u.moment(a,4) / Math.pow($u.moment(a,2),2);\r\n    return flag === 1 ? mom4: ((n + 1) * mom4 - 3 * (n - 1)) * (n - 1) / ((n - 2) *(n - 3)) + 3;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n   return NaN;\r\n }\r\n return $u.vectorfun(dim,x,_kurtosis,flag);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/mad.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method mad\r\n * @summary Mean absolute deviation\r\n * @description Mean absolute deviation\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * var c = [5,6,3];\r\n *\r\n * ubique.mad(c);\r\n * // 1.11111\r\n * \r\n * ubique.mad(a,1);\r\n * // [ [ 1, 1, 3 ] ]\r\n * \r\n * ubique.mad(a);\r\n * // [ [ 0.444444 ], [ 3.777778 ] ]\r\n */\r\n $u.mad = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  dim  = dim == null ? 0 : dim;\r\n\r\n  var _mad = function(a) {\r\n   return $u.mean($u.arrayfun($u.minus(a,$u.mean(a)),Math.abs));\r\n }\r\n if ($u.isnumber(x)) {\r\n   return 0;\r\n }\r\n return $u.vectorfun(dim,x,_mad);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/max.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method max\r\n * @summary Largest element in array\r\n * @description Largest element in array\r\n * \r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number} dim dimension selected, 1: column 0: row (def: 1)\r\n * @return {number|array|matrix}\r\n *\r\n * @example \r\n * ubique.max([5,6,-1]);\r\n * // 6\r\n * \r\n * ubique.max([[-1,3,-1],[4,5,9]]);\r\n * // [ [ 3 ], [ 9 ] ]\r\n * \r\n * ubique.max([[-1,3,-1],[4,5,9]],1);\r\n * // [ [ 4, 5, 9 ] ]\r\n */\r\n $u.max = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  dim  = dim == null ? 0 : dim;\r\n  var _max = function(a) {\r\n    return Math.max.apply(null,a);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n   return x;\r\n }\r\n return $u.vectorfun(dim,x,_max);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/mean.js":" /**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method mean\r\n * @summary Average value of array\r\n * @description Average value of array\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * var c = [5,6,3];\r\n *\r\n * ubique.mean(c);\r\n * // 4.66667\r\n * \r\n * ubique.mean([[5,6,5],[7,8,-1]]);\r\n * // [ [ 5.333333 ], [ 4.666667 ] ]\r\n * \r\n * ubique.mean([[5,6,5],[7,8,-1]],1);\r\n * // [ [ 6, 7, 2 ] ]\r\n */\r\n $u.mean = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  dim = dim == null ? 0 : dim;\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn x;\r\n \t}\r\n \tif ($u.isarray(x)) {\r\n \t\treturn  $u.sum(x,dim) / $u.numel(x);\r\n \t}\r\n \treturn $u.rdivide($u.sum(x,dim),$u.size(x)[1 - dim]);\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/median.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method median\r\n * @summary Median value of array\r\n * @description Median value of array\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * ubique.median([5,6,3]);\r\n * // 4.66667\r\n * \r\n * ubique.median([[5,6,5],[7,8,-1]]);\r\n * // [ [ 5 ], [ 7 ] ]\r\n * \r\n * ubique.median([[5,6,5],[7,8,-1]],1);\r\n * // [ [ 6, 7, 2 ] ]\r\n */\r\n $u.median = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tdim  = dim == null ? 0 : dim;\r\n\r\n \tvar _median = function(a) {\r\n \t\tvar n = a.length - 1;\r\n \t\tvar idx = $u.max(1,Math.floor(n / 2));\r\n \t\tvar _a = $u.sort(a);\r\n \t\tif( n % 2 === 0 ) {\r\n \t\t\treturn _a[idx];\r\n \t\t} else {\r\n \t\t\treturn (_a[idx - 1] + _a[idx]) / 2;\r\n \t\t}\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn x;\r\n \t}\r\n \treturn $u.vectorfun(dim,x,_median);\r\n }\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/min.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method min\r\n * @summary Smallest element in array\r\n * @description Smallest element in array\r\n *\r\n * @param  {array|matrix} x array or matrix of values\r\n * @param  {number} dim dimension selected, 1: column 0: row (def: 0)\r\n * @return {number|array|matrix}\r\n *\r\n * @example \r\n * ubique.min([5,6,-1]);\r\n * // -1\r\n * \r\n * ubique.min([[-1,3,-1],[4,5,9]]);\r\n * // [ [ -1 ], [ 4 ] ]\r\n * \r\n * ubique.min([[-1,3,-1],[4,5,9]],1);\r\n * // [ [ -1, 3, -1 ] ]\r\n */\r\n $u.min = function(x,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim  = dim == null ? 0 : dim;\r\n  var _min = function(a) {\r\n    return Math.min.apply(null,a);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n   return 0;\r\n }\r\n return $u.vectorfun(dim,x,_min);\r\n}\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/mode.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method mode\r\n * @summary Most frequent value in an array of elements \r\n * @description Most frequent value in an array of elements (Unimodal)\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * ubique.mode([5,6,3]);\r\n * // 3\r\n * \r\n * ubique.mode([[5,6,5],[7,8,-1]]);\r\n * // [ [ 5 ], [ -1 ] ]\r\n * \r\n * ubique.mode([[5,6,5],[7,8,-1]],1);\r\n * // [ [ 5, 6, -1 ] ]\r\n */\r\n $u.mode = function(x,dim) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  dim  = dim == null ? 0 : dim;\r\n\r\n  var _mode = function(a) {\r\n    var counter = {};\r\n    var mode = [];\r\n    var max = 0;\r\n    var _a = $u.sort(a);\r\n    for (var i = 0; i < x.length; i++) {\r\n      if (!(_a[i] in counter)) {\r\n        counter[_a[i]] = 0;\r\n      } else {\r\n        counter[_a[i]]++;\r\n      }\r\n      if (counter[_a[i]] === max) {\r\n        mode.push(_a[i]);\r\n      } else \r\n      if (counter[_a[i]] > max) {\r\n        max = counter[_a[i]];\r\n        mode = [_a[i]];\r\n      }\r\n    }\r\n    return mode[0];\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return x;\r\n  }\r\n  return $u.vectorfun(dim,x,_mode);\r\n\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/moment.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method moment\r\n * @summary Central moments\r\n * @description Central moments. First moment is zero, second is variance.\r\n * \r\n * @param  {array|matrix} x array or amatrix of elements\r\n * @param  {number} k k-th central sample moment\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * var x = [ 0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * ubique.moment(x,3);\r\n * // 0.000007\r\n * \r\n * ubique.moment(x,1);\r\n * // 0\r\n * \r\n * ubique.moment(ubique.cat(0,x,y),2);\r\n * // [ [ 0.000486 ], [ 0.00251 ] \r\n */\r\n $u.moment = function(x,k,dim) {\r\n \tif (arguments.length < 2) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n   dim  = dim == null ? 0 : dim;\r\n\r\n   var _moment = function(a,k) {\r\n     var mu = $u.mean(a);\r\n     return $u.mean(a.map(function(b) {return Math.pow(b - mu,k)}));\r\n   }\r\n   if ($u.isnumber(x)) {\r\n     return NaN;\r\n   }\r\n   return $u.vectorfun(dim,x,_moment,k);\r\n\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/pdist.js":"/**\r\n * Distance metrics\r\n */\r\nmodule.exports = function($u) {\r\n/**\r\n * @method pdist\r\n * @summary Pairwise distance between two sets of observations\r\n * @description  Compute distance between two array with differente methods:\r\n * euclidean, manhattan, chebycheb, hamming\r\n * \r\n * @param  {array} x array of values in X\r\n * @param  {array} y array of values in Y\r\n * @param  {string} mode methods: 'euclidean','manhattan','chebychev','hamming' (def: 'euclidean')\r\n * @return {number}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * ubique.pdist(x,y,'euclidean');\r\n * // 0.170532\r\n * \r\n * ubique.pdist(x,y,'manhattan');\r\n * // 0.471\r\n * \r\n * ubique.pdist(x,y,'chebychev');\r\n * // 0.087\r\n * \r\n * ubique.pdist(x,y,'hamming');\r\n * // 10\r\n */\r\n$u.pdist = function(x,y,mode) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  mode = mode == null ? 'euclidean' : mode;\r\n  var len = x.length;\r\n  var out = 0;\r\n  switch (mode) {\r\n    case \"euclidean\":\r\n      out = $u.sqrt($u.sum($u.power($u.minus(x,y),2)));\r\n      return out;\r\n      break;\r\n    case \"manhattan\": \r\n      out = $u.sum($u.abs($u.minus(x,y)));\r\n      return out;\r\n      break;\r\n    case \"chebychev\": \r\n      out = $u.max($u.abs($u.minus(x,y)));\r\n      return out;\r\n      break;\r\n    case \"hamming\": \r\n      for (var i=0;i<len;i++) {\r\n        if (x[i] !== y[i]) {\r\n          out++;\r\n        }\r\n      }\r\n      return out;\r\n      break;\r\n    default:\r\n      throw new Error('Invalid method');\r\n    }\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/prctile.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method prctile\r\n * @summary Percentiles of a sample\r\n * @description Percentiles of a sample, inclusive\r\n * \r\n * @param  {array|matrix} x array of emlements\r\n * @param  {number} p p-th percentile in the range [0,100]\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * var x = [ 0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * ubique.prctile(x,5);\r\n * // -0.014\r\n * \r\n * ubique.prctile(x,33);\r\n * // 0.0118\r\n * \r\n * ubique.prctile(ubique.cat(0,x,y),5);\r\n * // [ [ -0.014, -0.061 ] ]\r\n */\r\n $u.prctile = function(x,p,dim) {\r\n  if (arguments.length < 2) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if (p < 0 || p > 100) {\r\n    throw new Error('p-th percentile must be a real value between 0 and 100 inclusive');\r\n  }\r\n  dim = dim == null ? 0 : dim;\r\n  var _prctile = function(a,pr) {\r\n    var arrnum= $u.colon(0.5,a.length - 0.5);\r\n    var _a = $u.sort(a);\r\n    var pq = $u.rdivide($u.times(arrnum,100),a.length);\r\n    \r\n    pq = pq.concat(0,pq,100);\r\n    _a = _a.concat(_a[0],_a,_a[_a.length - 1]);\r\n    return $u.interp1(pq,_a,pr);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return x;\r\n  }\r\n  return $u.vectorfun(dim,x,_prctile,p);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/quantile.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method quantile\r\n * @summary Quantilies of a sample \r\n * @description Quantilies of a sample \r\n * \r\n * @param  {array|matrix} x array or matrix of elements\r\n * @param  {number} p p-th quantile in the range [0,1]\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * var x = [ 0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * ubique.quantile(x,0.25);\r\n * // 0.003\r\n * \r\n * ubique.quantile(ubique.cat(0,x,y),0.33);\r\n * // [ [ 0.0118, -0.0242 ] ]\r\n */\r\n $u.quantile = function(x,p,dim) {\r\n \tif (arguments.length < 2) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tif (p < 0 || p > 1) {\r\n \t\tthrow new Error('p-th percentile must be a real value between 0 and 1 inclusive');\r\n \t}\r\n \tdim = dim == null ? 0 : dim;\r\n \treturn $u.prctile(x,p*100,dim);\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/quartile.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method quartile\r\n * @summary Quartilies of a sample\r\n * @description Quartilies of a sample\r\n *\r\n * @param  {array|matrix} x array of values\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * var x = [ 0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n *\r\n * ubique.quartile(x);\r\n * // [ 0.003, 0.015, 0.026 ]\r\n * \r\n * ubique.quartile(ubique.cat(0,x,y));\r\n * // [ [ 0.003, 0.015, 0.026 ], [ -0.037, 0.0175, 0.058 ] ]\r\n */\r\n $u.quartile = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _quartile = function(a) {\r\n    return [$u.prctile(a,25),$u.prctile(a,50),$u.prctile(a,75)];\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_quartile);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/range.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method range\r\n * @summary Range of values\r\n * @description Range of values\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * var c = [5,6,3];\r\n *\r\n * ubique.range([5,6,3]);\r\n * // 3\r\n * \r\n * ubique.range([[5,6,5],[7,8,-1]]);\r\n * // [ [ 1 ], [ 9 ] ]\r\n * \r\n * ubique.range([[5,6,5],[7,8,-1]],1);\r\n * // [ [ 2, 2, 6 ] ]\r\n */\r\n $u.range = function(x,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tdim = dim == null ? 0 : dim;\r\n\r\n \tvar _range = function(a) {\r\n \t\treturn $u.max(a) - $u.min(a);\r\n \t}\r\n \tif ($u.isnumber(x)) {\r\n \t\treturn 0;\r\n \t}\r\n \treturn $u.vectorfun(dim,x,_range);\r\n }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/skewness.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method skewness\r\n * @summary Skewness\r\n * @description Skewness\r\n * \r\n * @param  {array|matrix} x array or matrix of elements\r\n * @param  {number} flag 0: bias correction, 1: simple (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * ubique.skewness(x);\r\n * // 0.617481\r\n * \r\n * ubique.skewness(ubique.cat(0,x,y));\r\n * // [ [ 0.617481 ], [ -0.118909 ] ]\r\n */\r\n $u.skewness = function(x,flag,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tflag = flag == null ? 1 : flag;\r\n  dim  = dim == null ? 0 : dim;\r\n\r\n  var _skewness = function(a,flag) {\r\n    var n = a.length;\r\n    var mom3 = $u.moment(a,3) / Math.pow($u.moment(a,2),1.5);\r\n    return flag === 1 ? mom3: Math.sqrt((n - 1) / n) * (n / (n - 2)) * mom3;\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_skewness,flag);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/std.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method std\r\n * @summary Standard deviation\r\n * @description Standard deviation\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} flag normalization value 0: population, 1:sample (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}   \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * var c = [5,6,3];\r\n *\r\n * ubique.std(c);\r\n * // 1.52753\r\n * \r\n * ubique.std(c,0);\r\n * // 1.24722 \r\n * \r\n * ubique.std(a,0);\r\n * // [ [ 0.471405 ], [ 4.027682 ] ]\r\n * \r\n * ubique.std(a,0,1);\r\n * // [ [ 1, 1, 3 ] ]\r\n */\r\n $u.std = function(x,flag,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tflag = flag == null ? 1 : flag;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n \tvar variance = $u.varc(x,flag,dim);\r\n \treturn $u.sqrt(variance);\r\n }\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/varc.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method varc\r\n * @summary Variance\r\n * @description  Variance\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} flag normalization value 0: population, 1:sample (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * var a = [[5,6,5],[7,8,-1]];\r\n * var c = [5,6,3];\r\n *\r\n * ubique.varc(c);\r\n * // 2.33333\r\n * \r\n * ubique.varc(c,0);\r\n * // 1.55556 \r\n * \r\n * ubique.varc(a,0);\r\n * // [ [ 0.222222 ], [ 16.222222 ] ]\r\n * \r\n * ubique.varc(a,0,1);\r\n * // [ [ 1, 1, 9 ] ]\r\n */\r\n $u.varc = function(x,flag,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n  flag = flag == null ? 1 : flag;\r\n  dim = dim == null ? 0 : dim;\r\n\r\n  var _varc = function(a,flag) {\r\n    var mu = $u.mean(a);\r\n    return ($u.sum($u.power($u.abs($u.minus(a,mu)),2))) / (a.length - flag);\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_varc,flag);\r\n}\r\n\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/xkurtosis.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method xkurtosis\r\n * @summary Excess kurtosis\r\n * @description Excess kurtosis\r\n * \r\n * @param  {array|matrix} x array or matrix of elements\r\n * @param  {number} flag 0: bias correction, 1: simple (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array|matrix}\r\n *\r\n * @example\r\n * var x = [0.003,0.026,0.015,-0.009,0.014,0.024,0.015,0.066,-0.014,0.039];\r\n * var y = [-0.005,0.081,0.04,-0.037,-0.061,0.058,-0.049,-0.021,0.062,0.058];\r\n * \r\n * ubique.xkurtosis(x);\r\n * // 0.037581\r\n * \r\n * ubique.xkurtosis(ubique.cat(0,x,y));\r\n * // [ [ 0.037581 ], [ -1.602358 ] ]\r\n */\r\n $u.xkurtosis = function(x,flag,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tflag = flag == null ? 1 : flag;\r\n  dim  = dim == null ? 0 : dim;\r\n\r\n  var kurt = $u.kurtosis(x,flag,dim);\r\n  if ($u.isnumber(kurt)) {\r\n    return kurt - 3;\r\n  }\r\n  return $u.arrayfun(kurt,function(a) {return a - 3;});\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/stats/zscore.js":"/**\r\n * Descriptive Statistic\r\n */\r\n module.exports = function($u) {\r\n/**\r\n * @method zscore\r\n * @summary Standardized Z score\r\n * @description Standardized Z score\r\n * \r\n * @param  {array|matrix} x array of values\r\n * @param  {number} flag normalization value 0: population, 1:sample (def: 1)\r\n * @param  {number} dim dimension 0: row, 1: column (def: 0)\r\n * @return {number|array}   \r\n *\r\n * @example\r\n * ubique.zscore([5,6,3]);\r\n * // [ 0.218218, 0.872872, -1.091089 ]\r\n * \r\n * ubique.zscore([[5,6,5],[7,8,-1]]);\r\n * // [ [ -0.57735, 1.154701, -0.57735 ],[ 0.473016, 0.675737, -1.148754 ] ]\r\n * \r\n * ubique.zscore([[5,6,5],[7,8,-1]],0,1);\r\n * // [ [ -1, -1, 1 ], [ 1, 1, -1 ] ]\r\n */\r\n $u.zscore = function(x,flag,dim) {\r\n \tif (arguments.length === 0) {\r\n \t\tthrow new Error('not enough input arguments');\r\n \t}\r\n \tflag = flag == null ? 1 : flag;\r\n  dim  = dim == null ? 0 : dim;\r\n\r\n  var _zscore = function(a,flag) {\r\n    return $u.rdivide($u.minus(a,$u.mean(a)),$u.std(a,flag));\r\n  }\r\n  if ($u.isnumber(x)) {\r\n    return NaN;\r\n  }\r\n  return $u.vectorfun(dim,x,_zscore,flag);\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/util/argsarray.js":"/**\r\n * Utility\r\n */\r\n module.exports = function ($u) {\r\n/**\r\n * @method argsarray\r\n * @summary Converting arguments to an array\r\n * @description Converting arguments to an array.  test case http://jsperf.com/converting-arguments-to-an-array/18\r\n * \r\n * @param  {number|string|boolean|...} args variable input arguments\r\n * @return {array}\r\n *  \r\n * @example\r\n * ubique.argsarray(99,true,'test',null);\r\n * // [ 99, true,'test', null ]\r\n */\r\n $u.argsarray = function() {\r\n  var arr = [];\r\n  for (var i = 0,len = arguments.length; i < len; i++) {\r\n     arr[i] = arguments[i];\r\n  }\r\n  return arr;\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/util/format.js":"/**\r\n * Utility\r\n */\r\n module.exports = function ($u) {\r\n/**\r\n * @method format\r\n * @summary Set display format for output (numbers)\r\n * @description Set display format for output (numbers)\r\n * \r\n * @param  {number|array|matrix} x input element\r\n * @param  {number} k number of decimals (def: 6 decimals)\r\n * @return {nuber|array|matrix}\r\n *  \r\n * @example\r\n * ubique.format(5.6677798348349,0);\r\n * // 6\r\n * \r\n * ubique.format([[-1000.47748,0.000002],[0.1483478,10.111100]],2);\r\n * // [ [ -1000.48, 0 ], [ 0.15, 10.11 ] ]\r\n */\r\n $u.format = function (x,k) {\r\n  if (arguments.length === 0) {\r\n    throw new Error('not enough input arguments');\r\n  }\r\n  if (!$u.isnumber(k)) {\r\n    k = 6;\r\n  }\r\n  var _format = function(a,k) {\r\n    return parseFloat(a.toFixed(k));\r\n  }\r\n  return $u.arrayfun(x,_format,k);\r\n}\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datafeed/yahoo.js":"/**\r\n * Datafeed\r\n */\r\n module.exports = function ($u) {\r\n/**\r\n * @method yahoo\r\n * @summary Download CSV Yahoo Finance historical (async request)\r\n * @description Download CSV Yahoo Finance historical. Returns an object:\r\n * \r\n * {\r\n *   'symbol': options.symbol,\r\n *   'from': options.from,\r\n *   'to': options.to,\r\n *   'period': options.period,\r\n *   'date': nDate,\r\n *   'open': nOpen,\r\n *   'high': nHigh,\r\n *   'low': nLow,\r\n *   'close': nClose,\r\n *   'volume': nVolume,\r\n *   'adjclose': nAdjClose\r\n * }\r\n *\r\n * @param {object} options options with fields:\r\n *                         .symbol Yahoo symbol name\r\n *                         .from start date\r\n *                         .to last date\r\n *                         .period period \"d\",\"w\",\"m\"\r\n *                         .fmt date format (def: \"YYYY-MM-DD\")\r\n * \r\n * @return {object} \r\n *\r\n * @example\r\n * // var options = {'symbol': 'AAPL','from': '2015-01-02','to': '2015-01-08','period': 'd'};\r\n * // ubique.yahoo.historical(options,function(err,data) {\r\n * // console.log(data)\r\n * // });\r\n * //\r\n * // { symbol: 'AAPL',\r\n * //     from: '2015-01-02',\r\n * //       to: '2015-01-08',\r\n * //   period: 'd',\r\n * //     date: [ '2015-01-02',\r\n * //             '2015-01-05',\r\n * //             '2015-01-06',\r\n * //             '2015-01-07',\r\n * //             '2015-01-08' ],\r\n * //             open: [ 111.39, 108.29, 106.54, 107.2, 109.23 ],\r\n * //             high: [ 111.44, 108.65, 107.43, 108.2, 112.15 ],\r\n * //             low: [ 107.35, 105.41, 104.63, 106.7, 108.7 ],\r\n * //             close: [ 109.33, 106.25, 106.26, 107.75, 111.89 ],\r\n * //             volume: [ 53204600, 64285500, 65797100, 40105900, 59364500 ],\r\n * //             adjclose: [ 108.44723, 105.3921, 105.40202, 106.87998, 110.98656 ] }\r\n */\r\n $u.yahoo = {\r\n  histurl: 'http://real-chart.finance.yahoo.com/table.csv?',\r\n  ip: '',\r\n  port: '',\r\n  historical: function(options,callback) {\r\n    options = options || {};\r\n    options.symbol = options.symbol || null;\r\n    options.from = options.from || null;\r\n    options.to = options.to || $u.datestr($u.today(),'YYYY-MM-DD');\r\n    options.period = options.period || 'd';\r\n    options.fmt = options.fmt || 'YYYY-MM-DD';\r\n    callback = callback || function() {};\r\n\r\n    var D = {};\r\n    var dates = [];\r\n    var values = [];\r\n    var sdt = $u.datevec(options.from,options.fmt);\r\n    var edt = $u.datevec(options.to,options.fmt);\r\n\r\n  // set URL string\r\n  var cvsdata = {};\r\n  var urlxp = '&ignore=.csv';\r\n  var urlsym = '&s=' + options.symbol.toUpperCase();\r\n  var urlfrom = '&a=' + (sdt[1] - 1) + '&b=' + sdt[2] + '&c=' + sdt[0];\r\n  var urlto = '&d=' + (edt[1] -1) + '&e=' + edt[2] + '&f=' + edt[0];\r\n  var urlperiod = '&g=' + options.period;\r\n  var URL = this.histurl + urlsym + urlfrom + urlto + urlperiod;\r\n\r\n  $u.__request(URL,function(err,res,body) {\r\n\r\n    cvsdata =  body.trim().split('\\n');\r\n    var header = cvsdata.shift().split(',');\r\n    var nDate = [];\r\n    var nOpen = [];\r\n    var nHigh = [];\r\n    var nLow = [];\r\n    var nClose = [];\r\n    var nVolume = [];\r\n    var nAdjClose = [];\r\n\r\n    cvsdata.sort().map(function(el) {\r\n      var temp = el.split(',');\r\n      nDate.push(temp[0]);\r\n      nOpen.push(Number(temp[1]));\r\n      nHigh.push(Number(temp[2]));\r\n      nLow.push(Number(temp[3]));\r\n      nClose.push(Number(temp[4]));\r\n      nVolume.push(Number(temp[5]));\r\n      nAdjClose.push(Number(temp[6]));\r\n    });\r\n\r\n    D = {\r\n      'symbol': options.symbol,\r\n      'from': options.from,\r\n      'to': options.to,\r\n      'period': options.period,\r\n      'date': nDate,\r\n      'open': nOpen,\r\n      'high': nHigh,\r\n      'low': nLow,\r\n      'close': nClose,\r\n      'volume': nVolume,\r\n      'adjclose': nAdjClose\r\n    };\r\n    callback(null,D);\r\n  });\r\n\r\n}\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/datafeed/yahooSync.js":"/**\r\n * Datafeed\r\n */\r\n module.exports = function ($u) {\r\n/**\r\n * @method yahooSync\r\n * @summary Download CSV Yahoo Finance historical (sync request)\r\n * @description Download CSV Yahoo Finance historical. Returns an object:\r\n * \r\n * {\r\n *   'symbol': options.symbol,\r\n *   'from': options.from,\r\n *   'to': options.to,\r\n *   'period': options.period,\r\n *   'date': nDate,\r\n *   'open': nOpen,\r\n *   'high': nHigh,\r\n *   'low': nLow,\r\n *   'close': nClose,\r\n *   'volume': nVolume,\r\n *   'adjclose': nAdjClose\r\n * }\r\n *\r\n * @param {object} options options with fields:\r\n *                         .symbol Yahoo symbol name\r\n *                         .from start date\r\n *                         .to last date\r\n *                         .period period \"d\",\"w\",\"m\"\r\n *                         .fmt date format (def: \"YYYY-MM-DD\")\r\n * \r\n * @return {object} \r\n *\r\n * @example\r\n * var options = { 'symbol': 'AAPL', 'from': '2015-01-02', 'to': '2015-01-08', 'period': 'd', 'fmt': 'YYYY-MM-DD' };\r\n * \r\n * ubique.yahooSync.historical(options);\r\n * //\r\n * // { symbol: 'AAPL',\r\n * //     from: '2015-01-02',\r\n * //       to: '2015-01-08',\r\n * //   period: 'd',\r\n * //     date: [ '2015-01-02',\r\n * //             '2015-01-05',\r\n * //             '2015-01-06',\r\n * //             '2015-01-07',\r\n * //             '2015-01-08' ],\r\n * //             open: [ 111.39, 108.29, 106.54, 107.2, 109.23 ],\r\n * //             high: [ 111.44, 108.65, 107.43, 108.2, 112.15 ],\r\n * //             low: [ 107.35, 105.41, 104.63, 106.7, 108.7 ],\r\n * //             close: [ 109.33, 106.25, 106.26, 107.75, 111.89 ],\r\n * //             volume: [ 53204600, 64285500, 65797100, 40105900, 59364500 ],\r\n * //             adjclose: [ 108.44723, 105.3921, 105.40202, 106.87998, 110.98656 ] }\r\n */\r\n $u.yahooSync = {\r\n  histurl: 'http://real-chart.finance.yahoo.com/table.csv?',\r\n  ip: '',\r\n  port: '',\r\n  historical: function(options) {\r\n    options = options || {};\r\n    options.symbol = options.symbol || null;\r\n    options.from = options.from || null;\r\n    options.to = options.to || $u.datestr($u.today(),'YYYY-MM-DD');\r\n    options.period = options.period || 'd';\r\n    options.fmt = options.fmt || 'YYYY-MM-DD';\r\n\r\n    var D = {};\r\n    var dates = [];\r\n    var values = [];\r\n    var sdt = $u.datevec(options.from,options.fmt);\r\n    var edt = $u.datevec(options.to,options.fmt);\r\n\r\n  // set URL string\r\n  var cvsdata = {};\r\n  var urlxp = '&ignore=.csv';\r\n  var urlsym = '&s=' + options.symbol.toUpperCase();\r\n  var urlfrom = '&a=' + (sdt[1] - 1) + '&b=' + sdt[2] + '&c=' + sdt[0];\r\n  var urlto = '&d=' + (edt[1] - 1) + '&e=' + edt[2] + '&f=' + edt[0];\r\n  var urlperiod = '&g=' + options.period;\r\n  var URL = this.histurl + urlsym + urlfrom + urlto + urlperiod;\r\n\r\n  var res = $u.__syncrequest('GET',URL);\r\n\r\n  cvsdata =  res.body.toString().trim().split('\\n');\r\n  var header = cvsdata.shift().split(',');\r\n  var nDate = [];\r\n  var nOpen = [];\r\n  var nHigh = [];\r\n  var nLow = [];\r\n  var nClose = [];\r\n  var nVolume = [];\r\n  var nAdjClose = [];\r\n\r\n  cvsdata.sort().map(function(el) {\r\n    var temp = el.split(',');\r\n    nDate.push(temp[0]);\r\n    nOpen.push(Number(temp[1]));\r\n    nHigh.push(Number(temp[2]));\r\n    nLow.push(Number(temp[3]));\r\n    nClose.push(Number(temp[4]));\r\n    nVolume.push(Number(temp[5]));\r\n    nAdjClose.push(Number(temp[6]));\r\n  });\r\n\r\n  D = {\r\n    'symbol': options.symbol,\r\n    'from': options.from,\r\n    'to': options.to,\r\n    'period': options.period,\r\n    'date': nDate,\r\n    'open': nOpen,\r\n    'high': nHigh,\r\n    'low': nLow,\r\n    'close': nClose,\r\n    'volume': nVolume,\r\n    'adjclose': nAdjClose\r\n  };\r\n  return D;\r\n\r\n}\r\n}\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-ubique/node_modules/ubique/lib/infoubique.js":"/**\r\n * name: #name\r\n * version: #version\r\n * update date: #last_update\r\n * \r\n * author: #author\r\n * homepage: #homepage\r\n * \r\n * description: #description\r\n * \r\n *\r\n * The MIT License (MIT)\r\n * \r\n * Copyright© 2014-2015 Max Todaro\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n"}